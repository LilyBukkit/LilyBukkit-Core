--- EntityMinecart.java
+++ EntityMinecart.java
@@ -1,17 +1,31 @@
 package net.minecraft.src;
 
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.Server;
+import org.bukkit.entity.Minecart;
+import org.bukkit.event.entity.EntityDamageEvent;
+import org.bukkit.util.Vector;
+
+import java.util.HashMap;
 import java.util.List;
+import java.util.UUID;
 
-public class EntityMinecart extends Entity implements IInventory {
-    private ItemStack[] cargoItems;
+public class EntityMinecart extends Entity implements IInventory, Minecart {
+    private static final int[][][] matrix;
+
+    static {
+        matrix = new int[][][]{{{0, 0, -1}, {0, 0, 1}}, {{-1, 0, 0}, {1, 0, 0}}, {{-1, -1, 0}, {1, 0, 0}}, {{-1, 0, 0}, {1, -1, 0}}, {{0, 0, -1}, {0, -1, 1}}, {{0, -1, -1}, {0, 0, 1}}, {{0, 0, 1}, {1, 0, 0}}, {{0, 0, 1}, {-1, 0, 0}}, {{0, 0, -1}, {-1, 0, 0}}, {{0, 0, -1}, {1, 0, 0}}};
+    }
+
     public int damageTaken;
     public int timeSinceHit;
     public int forwardDirection;
-    private boolean isInReverse;
     public int minecartType;
     public int fuel;
     public double pushX;
     public double pushZ;
-    private static final int[][][] matrix;
+    private ItemStack[] cargoItems;
+    private boolean isInReverse;
     private int turnProgress;
     private double minecartX;
@@ -20,9 +34,5 @@
     private double minecartYaw;
     private double minecartPitch;
-    
-    static {
-        matrix = new int[][][] { { { 0, 0, -1 }, { 0, 0, 1 } }, { { -1, 0, 0 }, { 1, 0, 0 } }, { { -1, -1, 0 }, { 1, 0, 0 } }, { { -1, 0, 0 }, { 1, -1, 0 } }, { { 0, 0, -1 }, { 0, -1, 1 } }, { { 0, -1, -1 }, { 0, 0, 1 } }, { { 0, 0, 1 }, { 1, 0, 0 } }, { { 0, 0, 1 }, { -1, 0, 0 } }, { { 0, 0, -1 }, { -1, 0, 0 } }, { { 0, 0, -1 }, { 1, 0, 0 } } };
-    }
-    
+
     public EntityMinecart(final World world) {
         super(world);
@@ -37,37 +47,37 @@
         this.canTriggerWalking = false;
     }
-    
+
+    public EntityMinecart(final World world, final double x, final double y, final double z, final int minecartType) {
+        this(world);
+        this.setPosition(x, y + this.yOffset, z);
+        this.motionX = 0.0;
+        this.motionY = 0.0;
+        this.motionZ = 0.0;
+        this.prevPosX = x;
+        this.prevPosY = y;
+        this.prevPosZ = z;
+        this.minecartType = minecartType;
+    }
+
     @Override
     public AxisAlignedBB getCollisionBox(final Entity entity) {
         return entity.boundingBox;
     }
-    
+
     @Override
     public AxisAlignedBB getBoundingBox() {
         return this.boundingBox;
     }
-    
+
     @Override
     public boolean canBePushed() {
         return true;
     }
-    
-    public EntityMinecart(final World world, final double x, final double y, final double z, final int minecartType) {
-        this(world);
-        this.setPosition(x, y + this.yOffset, z);
-        this.motionX = 0.0;
-        this.motionY = 0.0;
-        this.motionZ = 0.0;
-        this.prevPosX = x;
-        this.prevPosY = y;
-        this.prevPosZ = z;
-        this.minecartType = minecartType;
-    }
-    
+
     @Override
     public double getMountedYOffset() {
         return this.height * 0.0 - 0.30000001192092896;
     }
-    
+
     @Override
     public boolean attackEntityFrom(final Entity entity, final int damage) {
@@ -79,6 +89,5 @@
             if (this.minecartType == 1) {
                 this.entityDropItem(Block.chest.blockID, 1, 0.0f);
-            }
-            else if (this.minecartType == 2) {
+            } else if (this.minecartType == 2) {
                 this.entityDropItem(Block.stoneOvenIdle.blockID, 1, 0.0f);
             }
@@ -87,10 +96,10 @@
         return true;
     }
-    
+
     @Override
     public boolean canBeCollidedWith() {
         return !this.isDead;
     }
-    
+
     @Override
     public void setEntityDead() {
@@ -110,7 +119,7 @@
                     final EntityItem entityItem7 = new EntityItem(this.worldObj, this.posX + f3, this.posY + f4, this.posZ + f5, new ItemStack(itemStack2.itemID, i2, itemStack2.itemDmg));
                     final float f6 = 0.05f;
-                    entityItem7.motionX = (float)this.rand.nextGaussian() * f6;
-                    entityItem7.motionY = (float)this.rand.nextGaussian() * f6 + 0.2f;
-                    entityItem7.motionZ = (float)this.rand.nextGaussian() * f6;
+                    entityItem7.motionX = (float) this.rand.nextGaussian() * f6;
+                    entityItem7.motionY = (float) this.rand.nextGaussian() * f6 + 0.2f;
+                    entityItem7.motionZ = (float) this.rand.nextGaussian() * f6;
                     this.worldObj.spawnEntityInWorld(entityItem7);
                 }
@@ -119,5 +128,5 @@
         super.setEntityDead();
     }
-    
+
     @Override
     public void onUpdate() {
@@ -128,20 +137,19 @@
                 final double d43 = this.posZ + (this.minecartZ - this.posZ) / this.turnProgress;
                 double d44;
-                for (d44 = this.minecartYaw - this.rotationYaw; d44 < -180.0; d44 += 360.0) {}
+                for (d44 = this.minecartYaw - this.rotationYaw; d44 < -180.0; d44 += 360.0) {
+                }
                 while (d44 >= 180.0) {
                     d44 -= 360.0;
                 }
-                this.rotationYaw += (float)(d44 / this.turnProgress);
-                this.rotationPitch += (float)((this.minecartPitch - this.rotationPitch) / this.turnProgress);
+                this.rotationYaw += (float) (d44 / this.turnProgress);
+                this.rotationPitch += (float) ((this.minecartPitch - this.rotationPitch) / this.turnProgress);
                 --this.turnProgress;
                 this.setPosition(d41, d42, d43);
                 this.setRotation(this.rotationYaw, this.rotationPitch);
-            }
-            else {
+            } else {
                 this.setPosition(this.posX, this.posY, this.posZ);
                 this.setRotation(this.rotationYaw, this.rotationPitch);
             }
-        }
-        else {
+        } else {
             if (this.timeSinceHit > 0) {
                 --this.timeSinceHit;
@@ -204,10 +212,8 @@
                     this.posX = i1 + 0.5;
                     d51 = this.posZ - i3;
-                }
-                else if (d47 == 0.0) {
+                } else if (d47 == 0.0) {
                     this.posZ = i3 + 0.5;
                     d51 = this.posX - i1;
-                }
-                else {
+                } else {
                     final double d56 = this.posX - d52;
                     final double d57 = this.posZ - d53;
@@ -238,6 +244,5 @@
                 if (i5[0][1] != 0 && MathHelper.floor_double(this.posX) - i1 == i5[0][0] && MathHelper.floor_double(this.posZ) - i3 == i5[0][2]) {
                     this.setPosition(this.posX, this.posY + i5[0][1], this.posZ);
-                }
-                else if (i5[1][1] != 0 && MathHelper.floor_double(this.posX) - i1 == i5[1][0] && MathHelper.floor_double(this.posZ) - i3 == i5[1][2]) {
+                } else if (i5[1][1] != 0 && MathHelper.floor_double(this.posX) - i1 == i5[1][0] && MathHelper.floor_double(this.posZ) - i3 == i5[1][2]) {
                     this.setPosition(this.posX, this.posY + i5[1][1], this.posZ);
                 }
@@ -246,6 +251,5 @@
                     this.motionY *= 0.0;
                     this.motionZ *= 0.996999979019165;
-                }
-                else {
+                } else {
                     if (this.minecartType == 2) {
                         final double d58 = MathHelper.sqrt_double(this.pushX * this.pushX + this.pushZ * this.pushZ);
@@ -260,6 +264,5 @@
                             this.motionX += this.pushX * d59;
                             this.motionZ += this.pushZ * d59;
-                        }
-                        else {
+                        } else {
                             this.motionX *= 0.8999999761581421;
                             this.motionY *= 0.0;
@@ -296,6 +299,5 @@
                             this.pushX = 0.0;
                             this.pushZ = 0.0;
-                        }
-                        else {
+                        } else {
                             this.pushX = this.motionX;
                             this.pushZ = this.motionZ;
@@ -303,6 +305,5 @@
                     }
                 }
-            }
-            else {
+            } else {
                 if (this.motionX < -d45) {
                     this.motionX = -d45;
@@ -333,5 +334,5 @@
             final double d63 = this.prevPosZ - this.posZ;
             if (d62 * d62 + d63 * d63 > 0.001) {
-                this.rotationYaw = (float)(Math.atan2(d63, d62) * 180.0 / 3.141592653589793);
+                this.rotationYaw = (float) (Math.atan2(d63, d62) * 180.0 / 3.141592653589793);
                 if (this.isInReverse) {
                     this.rotationYaw += 180.0f;
@@ -339,5 +340,6 @@
             }
             double d64;
-            for (d64 = this.rotationYaw - this.prevRotationYaw; d64 >= 180.0; d64 -= 360.0) {}
+            for (d64 = this.rotationYaw - this.prevRotationYaw; d64 >= 180.0; d64 -= 360.0) {
+            }
             while (d64 < -180.0) {
                 d64 += 360.0;
@@ -351,5 +353,5 @@
             if (list15 != null && list15.size() > 0) {
                 for (int i8 = 0; i8 < list15.size(); ++i8) {
-                    final Entity entity17 = (Entity)list15.get(i8);
+                    final Entity entity17 = (Entity) list15.get(i8);
                     if (entity17 != this.riddenByEntity && entity17.canBePushed() && entity17 instanceof EntityMinecart) {
                         entity17.applyEntityCollision(this);
@@ -371,5 +373,5 @@
         }
     }
-    
+
     public Vec3D getPos(double x, double y, double z) {
         final int i7 = MathHelper.floor_double(x);
@@ -399,10 +401,8 @@
                 x = i7 + 0.5;
                 d12 = z - i9;
-            }
-            else if (d21 == 0.0) {
+            } else if (d21 == 0.0) {
                 z = i9 + 0.5;
                 d12 = x - i7;
-            }
-            else {
+            } else {
                 final double d22 = x - d13;
                 final double d23 = z - d15;
@@ -422,5 +422,5 @@
         return null;
     }
-    
+
     @Override
     protected void writeEntityToNBT(final NBTTagCompound nbttagcompound) {
@@ -429,20 +429,19 @@
             nbttagcompound.setDouble("PushX", this.pushX);
             nbttagcompound.setDouble("PushZ", this.pushZ);
-            nbttagcompound.setShort("Fuel", (short)this.fuel);
-        }
-        else if (this.minecartType == 1) {
+            nbttagcompound.setShort("Fuel", (short) this.fuel);
+        } else if (this.minecartType == 1) {
             final NBTTagList nBTTagList2 = new NBTTagList();
             for (int i3 = 0; i3 < this.cargoItems.length; ++i3) {
                 if (this.cargoItems[i3] != null) {
                     final NBTTagCompound nBTTagCompound4 = new NBTTagCompound();
-                    nBTTagCompound4.setByte("Slot", (byte)i3);
+                    nBTTagCompound4.setByte("Slot", (byte) i3);
                     this.cargoItems[i3].writeToNBT(nBTTagCompound4);
                     nBTTagList2.setTag(nBTTagCompound4);
                 }
             }
-            nbttagcompound.setTag("Items", (NBTBase)nBTTagList2);
+            nbttagcompound.setTag("Items", (NBTBase) nBTTagList2);
         }
     }
-    
+
     @Override
     protected void readEntityFromNBT(final NBTTagCompound nbttagcompound) {
@@ -452,10 +451,9 @@
             this.pushZ = nbttagcompound.getDouble("PushZ");
             this.fuel = nbttagcompound.getShort("Fuel");
-        }
-        else if (this.minecartType == 1) {
+        } else if (this.minecartType == 1) {
             final NBTTagList nBTTagList2 = nbttagcompound.getTagList("Items");
             this.cargoItems = new ItemStack[this.getSizeInventory()];
             for (int i3 = 0; i3 < nBTTagList2.tagCount(); ++i3) {
-                final NBTTagCompound nBTTagCompound4 = (NBTTagCompound)nBTTagList2.tagAt(i3);
+                final NBTTagCompound nBTTagCompound4 = (NBTTagCompound) nBTTagList2.tagAt(i3);
                 final int i4 = nBTTagCompound4.getByte("Slot") & 0xFF;
                 if (i4 >= 0 && i4 < this.cargoItems.length) {
@@ -465,5 +463,5 @@
         }
     }
-    
+
     @Override
     public void applyEntityCollision(final Entity entity) {
@@ -494,5 +492,5 @@
                     double d6 = entity.motionX + this.motionX;
                     double d7 = entity.motionZ + this.motionZ;
-                    if (((EntityMinecart)entity).minecartType == 2 && this.minecartType != 2) {
+                    if (((EntityMinecart) entity).minecartType == 2 && this.minecartType != 2) {
                         this.motionX *= 0.20000000298023224;
                         this.motionZ *= 0.20000000298023224;
@@ -500,6 +498,5 @@
                         entity.motionX *= 0.699999988079071;
                         entity.motionZ *= 0.699999988079071;
-                    }
-                    else if (((EntityMinecart)entity).minecartType != 2 && this.minecartType == 2) {
+                    } else if (((EntityMinecart) entity).minecartType != 2 && this.minecartType == 2) {
                         entity.motionX *= 0.20000000298023224;
                         entity.motionZ *= 0.20000000298023224;
@@ -507,6 +504,5 @@
                         this.motionX *= 0.699999988079071;
                         this.motionZ *= 0.699999988079071;
-                    }
-                    else {
+                    } else {
                         d6 /= 2.0;
                         d7 /= 2.0;
@@ -518,6 +514,5 @@
                         entity.addVelocity(d6 + d2, 0.0, d7 + d3);
                     }
-                }
-                else {
+                } else {
                     this.addVelocity(-d2, 0.0, -d3);
                     entity.addVelocity(d2 / 4.0, 0.0, d3 / 4.0);
@@ -526,13 +521,628 @@
         }
     }
-    
+
     @Override
     public int getSizeInventory() {
         return 27;
     }
-    
+
     @Override
     public ItemStack getStackInSlot(final int slot) {
         return this.cargoItems[slot];
     }
+
+    /**
+     * Gets a minecart's damage.
+     */
+    @Override
+    public int getDamage() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets a minecart's damage.
+     *
+     * @param damage over 40 to "kill" a minecart
+     */
+    @Override
+    public void setDamage(int damage) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the maximum speed of a minecart. The speed is unrelated to the velocity.
+     */
+    @Override
+    public double getMaxSpeed() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets the maximum speed of a minecart. Must be nonnegative. Default is 0.4D.
+     *
+     * @param speed
+     */
+    @Override
+    public void setMaxSpeed(double speed) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns whether this minecart will slow down faster without a passenger occupying it
+     */
+    @Override
+    public boolean isSlowWhenEmpty() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets whether this minecart will slow down faster without a passenger occupying it
+     *
+     * @param slow
+     */
+    @Override
+    public void setSlowWhenEmpty(boolean slow) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the flying velocity modifier. Used for minecarts that are in mid-air.
+     * A flying minecart's velocity is multiplied by this factor each tick.
+     */
+    @Override
+    public Vector getFlyingVelocityMod() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets the flying velocity modifier. Used for minecarts that are in mid-air.
+     * A flying minecart's velocity is multiplied by this factor each tick.
+     *
+     * @param flying velocity modifier
+     */
+    @Override
+    public void setFlyingVelocityMod(Vector flying) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the derailed velocity modifier. Used for minecarts that are on the ground, but not on rails.
+     * <p>
+     * A derailed minecart's velocity is multiplied by this factor each tick.
+     */
+    @Override
+    public Vector getDerailedVelocityMod() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets the derailed velocity modifier. Used for minecarts that are on the ground, but not on rails.
+     * A derailed minecart's velocity is multiplied by this factor each tick.
+     *
+     * @param derailed
+     */
+    @Override
+    public void setDerailedVelocityMod(Vector derailed) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the entity's current position
+     *
+     * @return Location containing the position of this entity
+     */
+    @Override
+    public Location getLocation() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets this entity's current velocity
+     *
+     * @return Current travelling velocity of this entity
+     */
+    @Override
+    public Vector getVelocity() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets this entity's velocity
+     *
+     * @param velocity New velocity to travel with
+     */
+    @Override
+    public void setVelocity(Vector velocity) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the current world this entity resides in
+     *
+     * @return World
+     */
+    @Override
+    public org.bukkit.World getWorld() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Teleports this entity to the given location
+     *
+     * @param location New location to teleport this entity to
+     * @return <code>true</code> if the teleport was successful
+     */
+    @Override
+    public boolean teleport(Location location) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Teleports this entity to the target Entity
+     *
+     * @param destination Entity to teleport this entity to
+     * @return <code>true</code> if the teleport was successful
+     */
+    @Override
+    public boolean teleport(org.bukkit.entity.Entity destination) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns a list of entities within a bounding box defined by x,y,z centered around player
+     *
+     * @param x Size of the box along x axis
+     * @param y Size of the box along y axis
+     * @param z Size of the box along z axis
+     * @return List<Entity> List of entities nearby
+     */
+    @Override
+    public List<org.bukkit.entity.Entity> getNearbyEntities(double x, double y, double z) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns a unique id for this entity
+     *
+     * @return Entity id
+     */
+    @Override
+    public int getEntityId() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns the entity's current fire ticks (ticks before the entity stops being on fire).
+     *
+     * @return int fireTicks
+     */
+    @Override
+    public int getFireTicks() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets the entity's current fire ticks (ticks before the entity stops being on fire).
+     *
+     * @param ticks
+     */
+    @Override
+    public void setFireTicks(int ticks) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns the entity's maximum fire ticks.
+     *
+     * @return int maxFireTicks
+     */
+    @Override
+    public int getMaxFireTicks() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Mark the entity's removal.
+     */
+    @Override
+    public void remove() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns true if this entity has been marked for removal.
+     */
+    @Override
+    public boolean isDead() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the {@link Server} that contains this Entity
+     *
+     * @return Server instance running this Entity
+     */
+    @Override
+    public Server getServer() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the primary passenger of a vehicle. For vehicles that could have
+     * multiple passengers, this will only return the primary passenger.
+     *
+     * @return an entity
+     */
+    @Override
+    public org.bukkit.entity.Entity getPassenger() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Set the passenger of a vehicle.
+     *
+     * @param passenger
+     * @return false if it could not be done for whatever reason
+     */
+    @Override
+    public boolean setPassenger(org.bukkit.entity.Entity passenger) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns true if the vehicle has no passengers.
+     *
+     * @return
+     */
+    @Override
+    public boolean isEmpty() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Eject any passenger. True if there was a passenger.
+     *
+     * @return
+     */
+    @Override
+    public boolean eject() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns the distance this entity has fallen
+     *
+     * @return
+     */
+    @Override
+    public float getFallDistance() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets the fall distance for this entity
+     *
+     * @param distance
+     */
+    @Override
+    public void setFallDistance(float distance) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Retrieve the last {@link EntityDamageEvent} inflicted on this entity. This event may have been cancelled.
+     *
+     * @return the last known {@link EntityDamageEvent} or null if hitherto unharmed
+     */
+    @Override
+    public EntityDamageEvent getLastDamageCause() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Record the last {@link EntityDamageEvent} inflicted on this entity
+     *
+     * @param event a {@link EntityDamageEvent}
+     */
+    @Override
+    public void setLastDamageCause(EntityDamageEvent event) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns a unique and persistent id for this entity
+     *
+     * @return unique id
+     */
+    @Override
+    public UUID getUniqueId() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns the size of the inventory
+     *
+     * @return The inventory size
+     */
+    @Override
+    public int getSize() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Return the name of the inventory
+     *
+     * @return The inventory name
+     */
+    @Override
+    public String getName() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Get the ItemStack found in the slot at the given index
+     *
+     * @param index The index of the Slot's ItemStack to return
+     * @return The ItemStack in the slot
+     */
+    @Override
+    public org.bukkit.inventory.ItemStack getItem(int index) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Stores the ItemStack at the given index
+     *
+     * @param index The index where to put the ItemStack
+     * @param item  The ItemStack to set
+     */
+    @Override
+    public void setItem(int index, org.bukkit.inventory.ItemStack item) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Stores the given ItemStacks in the inventory.
+     * <p>
+     * This will try to fill existing stacks and empty slots as good as it can.
+     * It will return a HashMap of what it couldn't fit.
+     *
+     * @param items The ItemStacks to add
+     * @return
+     */
+    @Override
+    public HashMap<Integer, org.bukkit.inventory.ItemStack> addItem(org.bukkit.inventory.ItemStack... items) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Removes the given ItemStacks from the inventory.
+     * <p>
+     * It will try to remove 'as much as possible' from the types and amounts you
+     * give as arguments. It will return a HashMap of what it couldn't remove.
+     *
+     * @param items The ItemStacks to remove
+     * @return
+     */
+    @Override
+    public HashMap<Integer, org.bukkit.inventory.ItemStack> removeItem(org.bukkit.inventory.ItemStack... items) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Get all ItemStacks from the inventory
+     *
+     * @return All the ItemStacks from all slots
+     */
+    @Override
+    public org.bukkit.inventory.ItemStack[] getContents() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Set the inventory's contents
+     *
+     * @param items
+     * @return All the ItemStacks from all slots
+     */
+    @Override
+    public void setContents(org.bukkit.inventory.ItemStack[] items) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Check if the inventory contains any ItemStacks with the given materialId
+     *
+     * @param materialId The materialId to check for
+     * @return If any ItemStacks were found
+     */
+    @Override
+    public boolean contains(int materialId) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Check if the inventory contains any ItemStacks with the given material
+     *
+     * @param material The material to check for
+     * @return If any ItemStacks were found
+     */
+    @Override
+    public boolean contains(Material material) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Check if the inventory contains any ItemStacks matching the given ItemStack
+     * This will only match if both the type and the amount of the stack match
+     *
+     * @param item The ItemStack to match against
+     * @return If any matching ItemStacks were found
+     */
+    @Override
+    public boolean contains(org.bukkit.inventory.ItemStack item) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Check if the inventory contains any ItemStacks with the given materialId and at least the minimum amount specified
+     *
+     * @param materialId The materialId to check for
+     * @param amount     The minimum amount to look for
+     * @return If any ItemStacks were found
+     */
+    @Override
+    public boolean contains(int materialId, int amount) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Check if the inventory contains any ItemStacks with the given material and at least the minimum amount specified
+     *
+     * @param material The material to check for
+     * @param amount
+     * @return If any ItemStacks were found
+     */
+    @Override
+    public boolean contains(Material material, int amount) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Check if the inventory contains any ItemStacks matching the given ItemStack and at least the minimum amount specified
+     * This will only match if both the type and the amount of the stack match
+     *
+     * @param item   The ItemStack to match against
+     * @param amount
+     * @return If any matching ItemStacks were found
+     */
+    @Override
+    public boolean contains(org.bukkit.inventory.ItemStack item, int amount) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Find all slots in the inventory containing any ItemStacks with the given materialId
+     *
+     * @param materialId The materialId to look for
+     * @return The Slots found.
+     */
+    @Override
+    public HashMap<Integer, ? extends org.bukkit.inventory.ItemStack> all(int materialId) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Find all slots in the inventory containing any ItemStacks with the given material
+     *
+     * @param material@return The Slots found.
+     */
+    @Override
+    public HashMap<Integer, ? extends org.bukkit.inventory.ItemStack> all(Material material) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Find all slots in the inventory containing any ItemStacks with the given ItemStack
+     * This will only match slots if both the type and the amount of the stack match
+     *
+     * @param item The ItemStack to match against
+     * @return The Slots found.
+     */
+    @Override
+    public HashMap<Integer, ? extends org.bukkit.inventory.ItemStack> all(org.bukkit.inventory.ItemStack item) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Find the first slot in the inventory containing an ItemStack with the given materialId
+     *
+     * @param materialId The materialId to look for
+     * @return The Slot found.
+     */
+    @Override
+    public int first(int materialId) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Find the first slot in the inventory containing an ItemStack with the given material
+     *
+     * @param material@return The Slot found.
+     */
+    @Override
+    public int first(Material material) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Find the first slot in the inventory containing an ItemStack with the given stack
+     * This will only match a slot if both the type and the amount of the stack match
+     *
+     * @param item The ItemStack to match against
+     * @return The Slot found.
+     */
+    @Override
+    public int first(org.bukkit.inventory.ItemStack item) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Find the first empty Slot.
+     *
+     * @return The first empty Slot found.
+     */
+    @Override
+    public int firstEmpty() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Remove all stacks in the inventory matching the given materialId.
+     *
+     * @param materialId The material to remove
+     */
+    @Override
+    public void remove(int materialId) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Remove all stacks in the inventory matching the given material.
+     *
+     * @param material The material to remove
+     */
+    @Override
+    public void remove(Material material) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Remove all stacks in the inventory matching the given stack.
+     * This will only match a slot if both the type and the amount of the stack match
+     *
+     * @param item The ItemStack to match against
+     */
+    @Override
+    public void remove(org.bukkit.inventory.ItemStack item) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Clear out a particular slot in the index
+     *
+     * @param index The index to empty.
+     */
+    @Override
+    public void clear(int index) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Clear out the whole index
+     */
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
 }
