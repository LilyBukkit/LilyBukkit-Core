--- BlockFurnace.java
+++ BlockFurnace.java
@@ -1,9 +1,13 @@
 package net.minecraft.src;
 
+import org.bukkit.block.Furnace;
+import org.bukkit.inventory.Inventory;
+import org.bukkit.material.MaterialData;
+
 import java.util.Random;
 
-public class BlockFurnace extends BlockContainer {
+public class BlockFurnace extends BlockContainer implements Furnace {
     private final boolean isActive;
-    
+
     protected BlockFurnace(final int id, final boolean isActive) {
         super(id, Material.rock);
@@ -11,10 +15,22 @@
         this.blockIndexInTexture = 45;
     }
-    
+
+    public static void updateFurnaceBlockState(final boolean isActive, final World world, final int x, final int y, final int z) {
+        final int i5 = world.getBlockMetadata(x, y, z);
+        final TileEntity tileEntity6 = world.getBlockTileEntity(x, y, z);
+        if (isActive) {
+            world.setBlockWithNotify(x, y, z, Block.stoneOvenActive.blockID);
+        } else {
+            world.setBlockWithNotify(x, y, z, Block.stoneOvenIdle.blockID);
+        }
+        world.setBlockMetadataWithNotify(x, y, z, i5);
+        world.setBlockTileEntity(x, y, z, tileEntity6);
+    }
+
     @Override
     public int idDropped(final int count, final Random random) {
         return Block.stoneOvenIdle.blockID;
     }
-    
+
     @Override
     public void onBlockAdded(final World world, final int x, final int y, final int z) {
@@ -22,5 +38,5 @@
         this.setDefaultDirection(world, x, y, z);
     }
-    
+
     private void setDefaultDirection(final World world, final int x, final int y, final int z) {
         final int i5 = world.getBlockId(x, y, z - 1);
@@ -43,33 +59,131 @@
         world.setBlockMetadataWithNotify(x, y, z, b9);
     }
-    
+
     @Override
     public int getBlockTextureFromSide(final int side) {
         return (side == 1) ? Block.stone.blockID : ((side == 0) ? Block.stone.blockID : ((side == 3) ? (this.blockIndexInTexture - 1) : this.blockIndexInTexture));
     }
-    
+
     @Override
     public boolean blockActivated(final World world, final int x, final int y, final int z, final EntityPlayer entityPlayer) {
-        final TileEntityFurnace tileEntityFurnace6 = (TileEntityFurnace)world.getBlockTileEntity(x, y, z);
+        final TileEntityFurnace tileEntityFurnace6 = (TileEntityFurnace) world.getBlockTileEntity(x, y, z);
         entityPlayer.displayGUIFurnace(tileEntityFurnace6);
         return true;
     }
-    
-    public static void updateFurnaceBlockState(final boolean isActive, final World world, final int x, final int y, final int z) {
-        final int i5 = world.getBlockMetadata(x, y, z);
-        final TileEntity tileEntity6 = world.getBlockTileEntity(x, y, z);
-        if (isActive) {
-            world.setBlockWithNotify(x, y, z, Block.stoneOvenActive.blockID);
-        }
-        else {
-            world.setBlockWithNotify(x, y, z, Block.stoneOvenIdle.blockID);
-        }
-        world.setBlockMetadataWithNotify(x, y, z, i5);
-        world.setBlockTileEntity(x, y, z, tileEntity6);
-    }
-    
+
     @Override
     protected TileEntity getBlockEntity() {
         return new TileEntityFurnace();
     }
+
+    /**
+     * Get the block's inventory.
+     *
+     * @return
+     */
+    @Override
+    public Inventory getInventory() {
+        return null;
+    }
+
+    /**
+     * Get burn time.
+     *
+     * @return
+     */
+    @Override
+    public short getBurnTime() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Set burn time.
+     *
+     * @param burnTime
+     */
+    @Override
+    public void setBurnTime(short burnTime) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Get cook time.
+     *
+     * @return
+     */
+    @Override
+    public short getCookTime() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Set cook time.
+     *
+     * @param cookTime
+     */
+    @Override
+    public void setCookTime(short cookTime) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the block represented by this BlockState
+     *
+     * @return Block that this BlockState represents
+     */
+    @Override
+    public org.bukkit.block.Block getBlock() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets the metadata for this block
+     *
+     * @param data New block specific metadata
+     */
+    @Override
+    public void setData(MaterialData data) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Attempts to update the block represented by this state, setting it to the
+     * new values as defined by this state. <br />
+     * <br />
+     * This has the same effect as calling update(false). That is to say,
+     * this will not modify the state of a block if it is no longer the same
+     * type as it was when this state was taken. It will return false in this
+     * eventuality.
+     *
+     * @return true if the update was successful, otherwise false
+     * @see org.bukkit.block.BlockState#update(boolean force)
+     */
+    @Override
+    public boolean update() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Attempts to update the block represented by this state, setting it to the
+     * new values as defined by this state. <br />
+     * <br />
+     * Unless force is true, this will not modify the state of a block if it is
+     * no longer the same type as it was when this state was taken. It will return
+     * false in this eventuality.<br />
+     * <br />
+     * If force is true, it will set the type of the block to match the new state,
+     * set the state data and then return true.
+     *
+     * @param force true to forcefully set the state
+     * @return true if the update was successful, otherwise false
+     */
+    @Override
+    public boolean update(boolean force) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    @Override
+    public byte getRawData() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
 }
