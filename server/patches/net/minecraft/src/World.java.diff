--- World.java
+++ World.java
@@ -1,7 +1,17 @@
 package net.minecraft.src;
 
+import org.bukkit.*;
+import org.bukkit.block.Biome;
+import org.bukkit.entity.*;
+import org.bukkit.entity.Item;
+import org.bukkit.generator.BlockPopulator;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.metadata.MetadataValue;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.util.Vector;
+
 import java.io.DataInputStream;
-import java.util.Iterator;
-import java.util.Collection;
+import java.util.*;
 import java.io.InputStream;
 import java.io.FileInputStream;
@@ -10,13 +20,7 @@
 import java.io.DataOutputStream;
 import java.io.FileOutputStream;
-import java.util.HashSet;
-import java.util.ArrayList;
 import java.io.File;
-import java.util.Random;
-import java.util.Set;
-import java.util.TreeSet;
-import java.util.List;
 
-public class World implements IBlockAccess {
+public class World implements IBlockAccess, org.bukkit.World {
     private List lightingToUpdate;
     public List loadedEntityList;
@@ -53,5 +57,5 @@
     public boolean worldChunkLoadOverride;
     private ArrayList collidingBoundingBoxes;
-    private Set positionsToUpdate;
+private Set<ChunkCoordIntPair> positionsToUpdate;
     private int soundCounter;
     private List entitiesWithinAABBExcludingEntity;
@@ -1579,3 +1583,1563 @@
         }
     }
+
+    /**
+     * Gets the {@link Block} at the given coordinates
+     *
+     * @param x X-coordinate of the block
+     * @param y Y-coordinate of the block
+     * @param z Z-coordinate of the block
+     * @return Block at the given coordinates
+     * @see #getBlockTypeIdAt(int, int, int) Returns the current type ID of
+     * the block
+     */
+    @Override
+    public org.bukkit.block.Block getBlockAt(int x, int y, int z) {
+        return null;
+    }
+
+    /**
+     * Gets the {@link Block} at the given {@link Location}
+     *
+     * @param location Location of the block
+     * @return Block at the given location
+     * @see #getBlockTypeIdAt(Location) Returns the current type ID
+     * of the block
+     */
+    @Override
+    public org.bukkit.block.Block getBlockAt(Location location) {
+        return null;
+    }
+
+    /**
+     * Gets the block type ID at the given coordinates
+     *
+     * @param x X-coordinate of the block
+     * @param y Y-coordinate of the block
+     * @param z Z-coordinate of the block
+     * @return Type ID of the block at the given coordinates
+     * @see #getBlockAt(int, int, int) Returns a live Block object at the
+     * given location
+     * @deprecated Magic value
+     */
+    @Override
+    public int getBlockTypeIdAt(int x, int y, int z) {
+        return 0;
+    }
+
+    /**
+     * Gets the block type ID at the given {@link Location}
+     *
+     * @param location Location of the block
+     * @return Type ID of the block at the given location
+     * @see #getBlockAt(Location) Returns a live Block object at
+     * the given location
+     * @deprecated Magic value
+     */
+    @Override
+    public int getBlockTypeIdAt(Location location) {
+        return 0;
+    }
+
+    /**
+     * Gets the highest non-air coordinate at the given coordinates
+     *
+     * @param x X-coordinate of the blocks
+     * @param z Z-coordinate of the blocks
+     * @return Y-coordinate of the highest non-air block
+     */
+    @Override
+    public int getHighestBlockYAt(int x, int z) {
+        return 0;
+    }
+
+    /**
+     * Gets the highest non-air coordinate at the given {@link Location}
+     *
+     * @param location Location of the blocks
+     * @return Y-coordinate of the highest non-air block
+     */
+    @Override
+    public int getHighestBlockYAt(Location location) {
+        return 0;
+    }
+
+    /**
+     * Gets the highest non-empty block at the given coordinates
+     *
+     * @param x X-coordinate of the block
+     * @param z Z-coordinate of the block
+     * @return Highest non-empty block
+     */
+    @Override
+    public org.bukkit.block.Block getHighestBlockAt(int x, int z) {
+        return null;
+    }
+
+    /**
+     * Gets the highest non-empty block at the given coordinates
+     *
+     * @param location Coordinates to get the highest block
+     * @return Highest non-empty block
+     */
+    @Override
+    public org.bukkit.block.Block getHighestBlockAt(Location location) {
+        return null;
+    }
+
+    /**
+     * Gets the {@link Chunk} at the given coordinates
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     * @return Chunk at the given coordinates
+     */
+    @Override
+    public org.bukkit.Chunk getChunkAt(int x, int z) {
+        return null;
+    }
+
+    /**
+     * Gets the {@link Chunk} at the given {@link Location}
+     *
+     * @param location Location of the chunk
+     * @return Chunk at the given location
+     */
+    @Override
+    public org.bukkit.Chunk getChunkAt(Location location) {
+        return null;
+    }
+
+    /**
+     * Gets the {@link Chunk} that contains the given {@link Block}
+     *
+     * @param block Block to get the containing chunk from
+     * @return The chunk that contains the given block
+     */
+    @Override
+    public org.bukkit.Chunk getChunkAt(org.bukkit.block.Block block) {
+        return null;
+    }
+
+    /**
+     * Checks if the specified {@link Chunk} is loaded
+     *
+     * @param chunk The chunk to check
+     * @return true if the chunk is loaded, otherwise false
+     */
+    @Override
+    public boolean isChunkLoaded(org.bukkit.Chunk chunk) {
+        return false;
+    }
+
+    /**
+     * Gets an array of all loaded {@link Chunk}s
+     *
+     * @return Chunk[] containing all loaded chunks
+     */
+    @Override
+    public org.bukkit.Chunk[] getLoadedChunks() {
+        return new org.bukkit.Chunk[0];
+    }
+
+    /**
+     * Loads the specified {@link Chunk}
+     *
+     * @param chunk The chunk to load
+     */
+    @Override
+    public void loadChunk(org.bukkit.Chunk chunk) {
+
+    }
+
+    /**
+     * Checks if the {@link Chunk} at the specified coordinates is loaded
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     * @return true if the chunk is loaded, otherwise false
+     */
+    @Override
+    public boolean isChunkLoaded(int x, int z) {
+        return false;
+    }
+
+    /**
+     * Checks if the {@link Chunk} at the specified coordinates is loaded and
+     * in use by one or more players
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     * @return true if the chunk is loaded and in use by one or more players,
+     * otherwise false
+     */
+    @Override
+    public boolean isChunkInUse(int x, int z) {
+        return false;
+    }
+
+    /**
+     * Loads the {@link Chunk} at the specified coordinates
+     * <p>
+     * If the chunk does not exist, it will be generated.
+     * <p>
+     * This method is analogous to {@link #loadChunk(int, int, boolean)} where
+     * generate is true.
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     */
+    @Override
+    public void loadChunk(int x, int z) {
+
+    }
+
+    /**
+     * Loads the {@link Chunk} at the specified coordinates
+     *
+     * @param x        X-coordinate of the chunk
+     * @param z        Z-coordinate of the chunk
+     * @param generate Whether or not to generate a chunk if it doesn't
+     *                 already exist
+     * @return true if the chunk has loaded successfully, otherwise false
+     */
+    @Override
+    public boolean loadChunk(int x, int z, boolean generate) {
+        return false;
+    }
+
+    /**
+     * Safely unloads and saves the {@link Chunk} at the specified coordinates
+     * <p>
+     * This method is analogous to {@link #unloadChunk(int, int, boolean,
+     * boolean)} where safe and saveis true
+     *
+     * @param chunk the chunk to unload
+     * @return true if the chunk has unloaded successfully, otherwise false
+     */
+    @Override
+    public boolean unloadChunk(org.bukkit.Chunk chunk) {
+        return false;
+    }
+
+    /**
+     * Safely unloads and saves the {@link Chunk} at the specified coordinates
+     * <p>
+     * This method is analogous to {@link #unloadChunk(int, int, boolean,
+     * boolean)} where safe and saveis true
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     * @return true if the chunk has unloaded successfully, otherwise false
+     */
+    @Override
+    public boolean unloadChunk(int x, int z) {
+        return false;
+    }
+
+    /**
+     * Safely unloads and optionally saves the {@link Chunk} at the specified
+     * coordinates
+     * <p>
+     * This method is analogous to {@link #unloadChunk(int, int, boolean,
+     * boolean)} where save is true
+     *
+     * @param x    X-coordinate of the chunk
+     * @param z    Z-coordinate of the chunk
+     * @param save Whether or not to save the chunk
+     * @return true if the chunk has unloaded successfully, otherwise false
+     */
+    @Override
+    public boolean unloadChunk(int x, int z, boolean save) {
+        return false;
+    }
+
+    /**
+     * Unloads and optionally saves the {@link Chunk} at the specified
+     * coordinates
+     *
+     * @param x    X-coordinate of the chunk
+     * @param z    Z-coordinate of the chunk
+     * @param save Controls whether the chunk is saved
+     * @param safe Controls whether to unload the chunk when players are
+     *             nearby
+     * @return true if the chunk has unloaded successfully, otherwise false
+     */
+    @Override
+    public boolean unloadChunk(int x, int z, boolean save, boolean safe) {
+        return false;
+    }
+
+    /**
+     * Safely queues the {@link Chunk} at the specified coordinates for
+     * unloading
+     * <p>
+     * This method is analogous to {@link #unloadChunkRequest(int, int,
+     * boolean)} where safe is true
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     * @return true is the queue attempt was successful, otherwise false
+     */
+    @Override
+    public boolean unloadChunkRequest(int x, int z) {
+        return false;
+    }
+
+    /**
+     * Queues the {@link Chunk} at the specified coordinates for unloading
+     *
+     * @param x    X-coordinate of the chunk
+     * @param z    Z-coordinate of the chunk
+     * @param safe Controls whether to queue the chunk when players are nearby
+     * @return Whether the chunk was actually queued
+     */
+    @Override
+    public boolean unloadChunkRequest(int x, int z, boolean safe) {
+        return false;
+    }
+
+    /**
+     * Regenerates the {@link Chunk} at the specified coordinates
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     * @return Whether the chunk was actually regenerated
+     */
+    @Override
+    public boolean regenerateChunk(int x, int z) {
+        return false;
+    }
+
+    /**
+     * Resends the {@link Chunk} to all clients
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     * @return Whether the chunk was actually refreshed
+     */
+    @Override
+    public boolean refreshChunk(int x, int z) {
+        return false;
+    }
+
+    /**
+     * Drops an item at the specified {@link Location}
+     *
+     * @param location Location to drop the item
+     * @param item     ItemStack to drop
+     * @return ItemDrop entity created as a result of this method
+     */
+    @Override
+    public Item dropItem(Location location, ItemStack item) {
+        return null;
+    }
+
+    /**
+     * Drops an item at the specified {@link Location} with a random offset
+     *
+     * @param location Location to drop the item
+     * @param item     ItemStack to drop
+     * @return ItemDrop entity created as a result of this method
+     */
+    @Override
+    public Item dropItemNaturally(Location location, ItemStack item) {
+        return null;
+    }
+
+    /**
+     * Creates an {@link Arrow} entity at the given {@link Location}
+     *
+     * @param location  Location to spawn the arrow
+     * @param direction Direction to shoot the arrow in
+     * @param speed     Speed of the arrow. A recommend speed is 0.6
+     * @param spread    Spread of the arrow. A recommend spread is 12
+     * @return Arrow entity spawned as a result of this method
+     */
+    @Override
+    public Arrow spawnArrow(Location location, Vector direction, float speed, float spread) {
+        return null;
+    }
+
+    /**
+     * Creates a tree at the given {@link Location}
+     *
+     * @param location Location to spawn the tree
+     * @param type     Type of the tree to create
+     * @return true if the tree was created successfully, otherwise false
+     */
+    @Override
+    public boolean generateTree(Location location, TreeType type) {
+        return false;
+    }
+
+    /**
+     * Creates a tree at the given {@link Location}
+     *
+     * @param loc      Location to spawn the tree
+     * @param type     Type of the tree to create
+     * @param delegate A class to call for each block changed as a result of
+     *                 this method
+     * @return true if the tree was created successfully, otherwise false
+     */
+    @Override
+    public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
+        return false;
+    }
+
+    /**
+     * Creates a entity at the given {@link Location}
+     *
+     * @param loc  The location to spawn the entity
+     * @param type The entity to spawn
+     * @return Resulting Entity of this method, or null if it was unsuccessful
+     */
+    @Override
+    public org.bukkit.entity.Entity spawnEntity(Location loc, EntityType type) {
+        return null;
+    }
+
+    /**
+     * Creates a creature at the given {@link Location}
+     *
+     * @param loc  The location to spawn the creature
+     * @param type The creature to spawn
+     * @return Resulting LivingEntity of this method, or null if it was
+     * unsuccessful
+     * @deprecated Has issues spawning non LivingEntities. Use {@link
+     * #spawnEntity(Location, EntityType) spawnEntity} instead.
+     */
+    @Override
+    public LivingEntity spawnCreature(Location loc, EntityType type) {
+        return null;
+    }
+
+    /**
+     * Creates a creature at the given {@link Location}
+     *
+     * @param loc  The location to spawn the creature
+     * @param type The creature to spawn
+     * @return Resulting LivingEntity of this method, or null if it was
+     * unsuccessful
+     */
+    @Override
+    public LivingEntity spawnCreature(Location loc, CreatureType type) {
+        return null;
+    }
+
+    /**
+     * Strikes lightning at the given {@link Location}
+     *
+     * @param loc The location to strike lightning
+     * @return The lightning entity.
+     */
+    @Override
+    public LightningStrike strikeLightning(Location loc) {
+        return null;
+    }
+
+    /**
+     * Strikes lightning at the given {@link Location} without doing damage
+     *
+     * @param loc The location to strike lightning
+     * @return The lightning entity.
+     */
+    @Override
+    public LightningStrike strikeLightningEffect(Location loc) {
+        return null;
+    }
+
+    /**
+     * Get a list of all entities in this World
+     *
+     * @return A List of all Entities currently residing in this world
+     */
+    @Override
+    public List<org.bukkit.entity.Entity> getEntities() {
+        return null;
+    }
+
+    /**
+     * Get a list of all living entities in this World
+     *
+     * @return A List of all LivingEntities currently residing in this world
+     */
+    @Override
+    public List<LivingEntity> getLivingEntities() {
+        return null;
+    }
+
+    /**
+     * Get a collection of all entities in this World matching the given
+     * class/interface
+     *
+     * @param classes The classes representing the types of entity to match
+     * @return A List of all Entities currently residing in this world that
+     * match the given class/interface
+     */
+    @Override
+    public <T extends org.bukkit.entity.Entity> Collection<T> getEntitiesByClass(Class<T>... classes) {
+        return null;
+    }
+
+    /**
+     * Get a collection of all entities in this World matching the given
+     * class/interface
+     *
+     * @param cls The class representing the type of entity to match
+     * @return A List of all Entities currently residing in this world that
+     * match the given class/interface
+     */
+    @Override
+    public <T extends org.bukkit.entity.Entity> Collection<T> getEntitiesByClass(Class<T> cls) {
+        return null;
+    }
+
+    /**
+     * Get a collection of all entities in this World matching any of the
+     * given classes/interfaces
+     *
+     * @param classes The classes representing the types of entity to match
+     * @return A List of all Entities currently residing in this world that
+     * match one or more of the given classes/interfaces
+     */
+    @Override
+    public Collection<org.bukkit.entity.Entity> getEntitiesByClasses(Class<?>... classes) {
+        return null;
+    }
+
+    /**
+     * Get a list of all players in this World
+     *
+     * @return A list of all Players currently residing in this world
+     */
+    @Override
+    public List<Player> getPlayers() {
+        return null;
+    }
+
+    /**
+     * Gets the unique name of this world
+     *
+     * @return Name of this world
+     */
+    @Override
+    public String getName() {
+        return null;
+    }
+
+    /**
+     * Gets the Unique ID of this world
+     *
+     * @return Unique ID of this world.
+     */
+    @Override
+    public UUID getUID() {
+        return null;
+    }
+
+    /**
+     * Gets the default spawn {@link Location} of this world
+     *
+     * @return The spawn location of this world
+     */
+    @Override
+    public Location getSpawnLocation() {
+        return null;
+    }
+
+    /**
+     * Sets the spawn location of the world
+     *
+     * @param x X coordinate
+     * @param y Y coordinate
+     * @param z Z coordinate
+     * @return True if it was successfully set.
+     */
+    @Override
+    public boolean setSpawnLocation(int x, int y, int z) {
+        return false;
+    }
+
+    /**
+     * Gets the relative in-game time of this world.
+     * <p>
+     * The relative time is analogous to hours * 1000
+     *
+     * @return The current relative time
+     * @see #getFullTime() Returns an absolute time of this world
+     */
+    @Override
+    public long getTime() {
+        return 0;
+    }
+
+    /**
+     * Sets the relative in-game time on the server.
+     * <p>
+     * The relative time is analogous to hours * 1000
+     * <p>
+     * Note that setting the relative time below the current relative time
+     * will actually move the clock forward a day. If you require to rewind
+     * time, please see {@link #setFullTime(long)}
+     *
+     * @param time The new relative time to set the in-game time to (in
+     *             hours*1000)
+     * @see #setFullTime(long) Sets the absolute time of this world
+     */
+    @Override
+    public void setTime(long time) {
+
+    }
+
+    /**
+     * Gets the full in-game time on this world
+     *
+     * @return The current absolute time
+     * @see #getTime() Returns a relative time of this world
+     */
+    @Override
+    public long getFullTime() {
+        return 0;
+    }
+
+    /**
+     * Sets the in-game time on the server
+     * <p>
+     * Note that this sets the full time of the world, which may cause adverse
+     * effects such as breaking redstone clocks and any scheduled events
+     *
+     * @param time The new absolute time to set this world to
+     * @see #setTime(long) Sets the relative time of this world
+     */
+    @Override
+    public void setFullTime(long time) {
+
+    }
+
+    /**
+     * Returns whether the world has an ongoing storm.
+     *
+     * @return Whether there is an ongoing storm
+     */
+    @Override
+    public boolean hasStorm() {
+        return false;
+    }
+
+    /**
+     * Set whether there is a storm. A duration will be set for the new
+     * current conditions.
+     *
+     * @param hasStorm Whether there is rain and snow
+     */
+    @Override
+    public void setStorm(boolean hasStorm) {
+
+    }
+
+    /**
+     * Get the remaining time in ticks of the current conditions.
+     *
+     * @return Time in ticks
+     */
+    @Override
+    public int getWeatherDuration() {
+        return 0;
+    }
+
+    /**
+     * Set the remaining time in ticks of the current conditions.
+     *
+     * @param duration Time in ticks
+     */
+    @Override
+    public void setWeatherDuration(int duration) {
+
+    }
+
+    /**
+     * Returns whether there is thunder.
+     *
+     * @return Whether there is thunder
+     */
+    @Override
+    public boolean isThundering() {
+        return false;
+    }
+
+    /**
+     * Set whether it is thundering.
+     *
+     * @param thundering Whether it is thundering
+     */
+    @Override
+    public void setThundering(boolean thundering) {
+
+    }
+
+    /**
+     * Get the thundering duration.
+     *
+     * @return Duration in ticks
+     */
+    @Override
+    public int getThunderDuration() {
+        return 0;
+    }
+
+    /**
+     * Set the thundering duration.
+     *
+     * @param duration Duration in ticks
+     */
+    @Override
+    public void setThunderDuration(int duration) {
+
+    }
+
+    /**
+     * Creates explosion at given coordinates with given power
+     *
+     * @param x     X coordinate
+     * @param y     Y coordinate
+     * @param z     Z coordinate
+     * @param power The power of explosion, where 4F is TNT
+     * @return false if explosion was canceled, otherwise true
+     */
+    @Override
+    public boolean createExplosion(double x, double y, double z, float power) {
+        return false;
+    }
+
+    /**
+     * Creates explosion at given coordinates with given power and optionally
+     * setting blocks on fire.
+     *
+     * @param x       X coordinate
+     * @param y       Y coordinate
+     * @param z       Z coordinate
+     * @param power   The power of explosion, where 4F is TNT
+     * @param setFire Whether or not to set blocks on fire
+     * @return false if explosion was canceled, otherwise true
+     */
+    @Override
+    public boolean createExplosion(double x, double y, double z, float power, boolean setFire) {
+        return false;
+    }
+
+    /**
+     * Creates explosion at given coordinates with given power and optionally
+     * setting blocks on fire or breaking blocks.
+     *
+     * @param x           X coordinate
+     * @param y           Y coordinate
+     * @param z           Z coordinate
+     * @param power       The power of explosion, where 4F is TNT
+     * @param setFire     Whether or not to set blocks on fire
+     * @param breakBlocks Whether or not to have blocks be destroyed
+     * @return false if explosion was canceled, otherwise true
+     */
+    @Override
+    public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks) {
+        return false;
+    }
+
+    /**
+     * Creates explosion at given coordinates with given power
+     *
+     * @param loc   Location to blow up
+     * @param power The power of explosion, where 4F is TNT
+     * @return false if explosion was canceled, otherwise true
+     */
+    @Override
+    public boolean createExplosion(Location loc, float power) {
+        return false;
+    }
+
+    /**
+     * Creates explosion at given coordinates with given power and optionally
+     * setting blocks on fire.
+     *
+     * @param loc     Location to blow up
+     * @param power   The power of explosion, where 4F is TNT
+     * @param setFire Whether or not to set blocks on fire
+     * @return false if explosion was canceled, otherwise true
+     */
+    @Override
+    public boolean createExplosion(Location loc, float power, boolean setFire) {
+        return false;
+    }
+
+    /**
+     * Gets the {@link Environment} type of this world
+     *
+     * @return This worlds Environment type
+     */
+    @Override
+    public Environment getEnvironment() {
+        return null;
+    }
+
+    /**
+     * Gets the Seed for this world.
+     *
+     * @return This worlds Seed
+     */
+    @Override
+    public long getSeed() {
+        return 0;
+    }
+
+    /**
+     * Gets the current PVP setting for this world.
+     *
+     * @return True if PVP is enabled
+     */
+    @Override
+    public boolean getPVP() {
+        return false;
+    }
+
+    /**
+     * Sets the PVP setting for this world.
+     *
+     * @param pvp True/False whether PVP should be Enabled.
+     */
+    @Override
+    public void setPVP(boolean pvp) {
+
+    }
+
+    /**
+     * Gets the chunk generator for this world
+     *
+     * @return ChunkGenerator associated with this world
+     */
+    @Override
+    public ChunkGenerator getGenerator() {
+        return null;
+    }
+
+    /**
+     * Saves world to disk
+     */
+    @Override
+    public void save() {
+
+    }
+
+    /**
+     * Gets a list of all applied {@link BlockPopulator}s for this World
+     *
+     * @return List containing any or none BlockPopulators
+     */
+    @Override
+    public List<BlockPopulator> getPopulators() {
+        return null;
+    }
+
+    /**
+     * Spawn an entity of a specific class at the given {@link Location}
+     *
+     * @param location the {@link Location} to spawn the entity at
+     * @param clazz    the class of the {@link Entity} to spawn
+     * @return an instance of the spawned {@link Entity}
+     * @throws IllegalArgumentException if either parameter is null or the
+     *                                  {@link Entity} requested cannot be spawned
+     */
+    @Override
+    public <T extends org.bukkit.entity.Entity> T spawn(Location location, Class<T> clazz) throws IllegalArgumentException {
+        return null;
+    }
+
+    /**
+     * Spawn a {@link FallingBlock} entity at the given {@link Location} of
+     * the specified {@link Material}. The material dictates what is falling.
+     * When the FallingBlock hits the ground, it will place that block.
+     * <p>
+     * The Material must be a block type, check with {@link Material#isBlock()
+     * material.isBlock()}. The Material may not be air.
+     *
+     * @param location The {@link Location} to spawn the FallingBlock
+     * @param material The block {@link Material} type
+     * @param data     The block data
+     * @return The spawned {@link FallingBlock} instance
+     * @throws IllegalArgumentException if {@link Location} or {@link
+     *                                  Material} are null or {@link Material} is not a block
+     * @deprecated Magic value
+     */
+    @Override
+    public FallingBlock spawnFallingBlock(Location location, org.bukkit.Material material, byte data) throws IllegalArgumentException {
+        return null;
+    }
+
+    /**
+     * Spawn a {@link FallingBlock} entity at the given {@link Location} of
+     * the specified blockId (converted to {@link Material})
+     *
+     * @param location  The {@link Location} to spawn the FallingBlock
+     * @param blockId   The id of the intended material
+     * @param blockData The block data
+     * @return The spawned FallingBlock instance
+     * @throws IllegalArgumentException if location is null, or blockId is
+     *                                  invalid
+     * @see #spawnFallingBlock(Location, org.bukkit.Material, byte)
+     * @deprecated Magic value
+     */
+    @Override
+    public FallingBlock spawnFallingBlock(Location location, int blockId, byte blockData) throws IllegalArgumentException {
+        return null;
+    }
+
+    /**
+     * Plays an effect to all players within a default radius around a given
+     * location.
+     *
+     * @param location the {@link Location} around which players must be to
+     *                 hear the sound
+     * @param effect   the {@link Effect}
+     * @param data     a data bit needed for some effects
+     */
+    @Override
+    public void playEffect(Location location, Effect effect, int data) {
+
+    }
+
+    /**
+     * Plays an effect to all players within a given radius around a location.
+     *
+     * @param location the {@link Location} around which players must be to
+     *                 hear the effect
+     * @param effect   the {@link Effect}
+     * @param data     a data bit needed for some effects
+     * @param radius   the radius around the location
+     */
+    @Override
+    public void playEffect(Location location, Effect effect, int data, int radius) {
+
+    }
+
+    /**
+     * Plays an effect to all players within a default radius around a given
+     * location.
+     *
+     * @param location the {@link Location} around which players must be to
+     *                 hear the sound
+     * @param effect   the {@link Effect}
+     * @param data     a data bit needed for some effects
+     */
+    @Override
+    public <T> void playEffect(Location location, Effect effect, T data) {
+
+    }
+
+    /**
+     * Plays an effect to all players within a given radius around a location.
+     *
+     * @param location the {@link Location} around which players must be to
+     *                 hear the effect
+     * @param effect   the {@link Effect}
+     * @param data     a data bit needed for some effects
+     * @param radius   the radius around the location
+     */
+    @Override
+    public <T> void playEffect(Location location, Effect effect, T data, int radius) {
+
+    }
+
+    /**
+     * Get empty chunk snapshot (equivalent to all air blocks), optionally
+     * including valid biome data. Used for representing an ungenerated chunk,
+     * or for fetching only biome data without loading a chunk.
+     *
+     * @param x                    - chunk x coordinate
+     * @param z                    - chunk z coordinate
+     * @param includeBiome         - if true, snapshot includes per-coordinate biome
+     *                             type
+     * @param includeBiomeTempRain - if true, snapshot includes per-coordinate
+     *                             raw biome temperature and rainfall
+     * @return The empty snapshot.
+     */
+    @Override
+    public ChunkSnapshot getEmptyChunkSnapshot(int x, int z, boolean includeBiome, boolean includeBiomeTempRain) {
+        return null;
+    }
+
+    /**
+     * Sets the spawn flags for this.
+     *
+     * @param allowMonsters - if true, monsters are allowed to spawn in this
+     *                      world.
+     * @param allowAnimals  - if true, animals are allowed to spawn in this
+     *                      world.
+     */
+    @Override
+    public void setSpawnFlags(boolean allowMonsters, boolean allowAnimals) {
+
+    }
+
+    /**
+     * Gets whether animals can spawn in this world.
+     *
+     * @return whether animals can spawn in this world.
+     */
+    @Override
+    public boolean getAllowAnimals() {
+        return false;
+    }
+
+    /**
+     * Gets whether monsters can spawn in this world.
+     *
+     * @return whether monsters can spawn in this world.
+     */
+    @Override
+    public boolean getAllowMonsters() {
+        return false;
+    }
+
+    /**
+     * Gets the biome for the given block coordinates.
+     *
+     * @param x X coordinate of the block
+     * @param z Z coordinate of the block
+     * @return Biome of the requested block
+     */
+    @Override
+    public Biome getBiome(int x, int z) {
+        return null;
+    }
+
+    /**
+     * Sets the biome for the given block coordinates
+     *
+     * @param x   X coordinate of the block
+     * @param z   Z coordinate of the block
+     * @param bio new Biome type for this block
+     */
+    @Override
+    public void setBiome(int x, int z, Biome bio) {
+
+    }
+
+    /**
+     * Gets the temperature for the given block coordinates.
+     * <p>
+     * It is safe to run this method when the block does not exist, it will
+     * not create the block.
+     *
+     * @param x X coordinate of the block
+     * @param z Z coordinate of the block
+     * @return Temperature of the requested block
+     */
+    @Override
+    public double getTemperature(int x, int z) {
+        return 0;
+    }
+
+    /**
+     * Gets the humidity for the given block coordinates.
+     * <p>
+     * It is safe to run this method when the block does not exist, it will
+     * not create the block.
+     *
+     * @param x X coordinate of the block
+     * @param z Z coordinate of the block
+     * @return Humidity of the requested block
+     */
+    @Override
+    public double getHumidity(int x, int z) {
+        return 0;
+    }
+
+    /**
+     * Gets the maximum height of this world.
+     * <p>
+     * If the max height is 100, there are only blocks from y=0 to y=99.
+     *
+     * @return Maximum height of the world
+     */
+    @Override
+    public int getMaxHeight() {
+        return 0;
+    }
+
+    /**
+     * Gets the sea level for this world.
+     * <p>
+     * This is often half of {@link #getMaxHeight()}
+     *
+     * @return Sea level
+     */
+    @Override
+    public int getSeaLevel() {
+        return 0;
+    }
+
+    /**
+     * Gets whether the world's spawn area should be kept loaded into memory
+     * or not.
+     *
+     * @return true if the world's spawn area will be kept loaded into memory.
+     */
+    @Override
+    public boolean getKeepSpawnInMemory() {
+        return false;
+    }
+
+    /**
+     * Sets whether the world's spawn area should be kept loaded into memory
+     * or not.
+     *
+     * @param keepLoaded if true then the world's spawn area will be kept
+     *                   loaded into memory.
+     */
+    @Override
+    public void setKeepSpawnInMemory(boolean keepLoaded) {
+
+    }
+
+    /**
+     * Gets whether or not the world will automatically save
+     *
+     * @return true if the world will automatically save, otherwise false
+     */
+    @Override
+    public boolean isAutoSave() {
+        return false;
+    }
+
+    /**
+     * Sets whether or not the world will automatically save
+     *
+     * @param value true if the world should automatically save, otherwise
+     *              false
+     */
+    @Override
+    public void setAutoSave(boolean value) {
+
+    }
+
+    /**
+     * Sets the Difficulty of the world.
+     *
+     * @param difficulty the new difficulty you want to set the world to
+     */
+    @Override
+    public void setDifficulty(Difficulty difficulty) {
+
+    }
+
+    /**
+     * Gets the Difficulty of the world.
+     *
+     * @return The difficulty of the world.
+     */
+    @Override
+    public Difficulty getDifficulty() {
+        return null;
+    }
+
+    /**
+     * Gets the folder of this world on disk.
+     *
+     * @return The folder of this world.
+     */
+    @Override
+    public File getWorldFolder() {
+        return null;
+    }
+
+    /**
+     * Gets the type of this world.
+     *
+     * @return Type of this world.
+     */
+    @Override
+    public WorldType getWorldType() {
+        return null;
+    }
+
+    /**
+     * Gets whether or not structures are being generated.
+     *
+     * @return True if structures are being generated.
+     */
+    @Override
+    public boolean canGenerateStructures() {
+        return false;
+    }
+
+    /**
+     * Gets the world's ticks per animal spawns value
+     * <p>
+     * This value determines how many ticks there are between attempts to
+     * spawn animals.
+     * <p>
+     * <b>Example Usage:</b>
+     * <ul>
+     * <li>A value of 1 will mean the server will attempt to spawn animals in
+     *     this world every tick.
+     * <li>A value of 400 will mean the server will attempt to spawn animals
+     *     in this world every 400th tick.
+     * <li>A value below 0 will be reset back to Minecraft's default.
+     * </ul>
+     * <p>
+     * <b>Note:</b>
+     * If set to 0, animal spawning will be disabled for this world. We
+     * recommend using {@link #setSpawnFlags(boolean, boolean)} to control
+     * this instead.
+     * <p>
+     * Minecraft default: 400.
+     *
+     * @return The world's ticks per animal spawns value
+     */
+    @Override
+    public long getTicksPerAnimalSpawns() {
+        return 0;
+    }
+
+    /**
+     * Sets the world's ticks per animal spawns value
+     * <p>
+     * This value determines how many ticks there are between attempts to
+     * spawn animals.
+     * <p>
+     * <b>Example Usage:</b>
+     * <ul>
+     * <li>A value of 1 will mean the server will attempt to spawn animals in
+     *     this world every tick.
+     * <li>A value of 400 will mean the server will attempt to spawn animals
+     *     in this world every 400th tick.
+     * <li>A value below 0 will be reset back to Minecraft's default.
+     * </ul>
+     * <p>
+     * <b>Note:</b>
+     * If set to 0, animal spawning will be disabled for this world. We
+     * recommend using {@link #setSpawnFlags(boolean, boolean)} to control
+     * this instead.
+     * <p>
+     * Minecraft default: 400.
+     *
+     * @param ticksPerAnimalSpawns the ticks per animal spawns value you want
+     *                             to set the world to
+     */
+    @Override
+    public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns) {
+
+    }
+
+    /**
+     * Gets the world's ticks per monster spawns value
+     * <p>
+     * This value determines how many ticks there are between attempts to
+     * spawn monsters.
+     * <p>
+     * <b>Example Usage:</b>
+     * <ul>
+     * <li>A value of 1 will mean the server will attempt to spawn monsters in
+     *     this world every tick.
+     * <li>A value of 400 will mean the server will attempt to spawn monsters
+     *     in this world every 400th tick.
+     * <li>A value below 0 will be reset back to Minecraft's default.
+     * </ul>
+     * <p>
+     * <b>Note:</b>
+     * If set to 0, monsters spawning will be disabled for this world. We
+     * recommend using {@link #setSpawnFlags(boolean, boolean)} to control
+     * this instead.
+     * <p>
+     * Minecraft default: 1.
+     *
+     * @return The world's ticks per monster spawns value
+     */
+    @Override
+    public long getTicksPerMonsterSpawns() {
+        return 0;
+    }
+
+    /**
+     * Sets the world's ticks per monster spawns value
+     * <p>
+     * This value determines how many ticks there are between attempts to
+     * spawn monsters.
+     * <p>
+     * <b>Example Usage:</b>
+     * <ul>
+     * <li>A value of 1 will mean the server will attempt to spawn monsters in
+     *     this world on every tick.
+     * <li>A value of 400 will mean the server will attempt to spawn monsters
+     *     in this world every 400th tick.
+     * <li>A value below 0 will be reset back to Minecraft's default.
+     * </ul>
+     * <p>
+     * <b>Note:</b>
+     * If set to 0, monsters spawning will be disabled for this world. We
+     * recommend using {@link #setSpawnFlags(boolean, boolean)} to control
+     * this instead.
+     * <p>
+     * Minecraft default: 1.
+     *
+     * @param ticksPerMonsterSpawns the ticks per monster spawns value you
+     *                              want to set the world to
+     */
+    @Override
+    public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns) {
+
+    }
+
+    /**
+     * Gets limit for number of monsters that can spawn in a chunk in this
+     * world
+     *
+     * @return The monster spawn limit
+     */
+    @Override
+    public int getMonsterSpawnLimit() {
+        return 0;
+    }
+
+    /**
+     * Sets the limit for number of monsters that can spawn in a chunk in this
+     * world
+     * <p>
+     * <b>Note:</b> If set to a negative number the world will use the
+     * server-wide spawn limit instead.
+     *
+     * @param limit
+     */
+    @Override
+    public void setMonsterSpawnLimit(int limit) {
+
+    }
+
+    /**
+     * Gets the limit for number of animals that can spawn in a chunk in this
+     * world
+     *
+     * @return The animal spawn limit
+     */
+    @Override
+    public int getAnimalSpawnLimit() {
+        return 0;
+    }
+
+    /**
+     * Sets the limit for number of animals that can spawn in a chunk in this
+     * world
+     * <p>
+     * <b>Note:</b> If set to a negative number the world will use the
+     * server-wide spawn limit instead.
+     *
+     * @param limit
+     */
+    @Override
+    public void setAnimalSpawnLimit(int limit) {
+
+    }
+
+    /**
+     * Gets the limit for number of water animals that can spawn in a chunk in
+     * this world
+     *
+     * @return The water animal spawn limit
+     */
+    @Override
+    public int getWaterAnimalSpawnLimit() {
+        return 0;
+    }
+
+    /**
+     * Sets the limit for number of water animals that can spawn in a chunk in
+     * this world
+     * <p>
+     * <b>Note:</b> If set to a negative number the world will use the
+     * server-wide spawn limit instead.
+     *
+     * @param limit
+     */
+    @Override
+    public void setWaterAnimalSpawnLimit(int limit) {
+
+    }
+
+    /**
+     * Gets the limit for number of ambient mobs that can spawn in a chunk in
+     * this world
+     *
+     * @return The ambient spawn limit
+     */
+    @Override
+    public int getAmbientSpawnLimit() {
+        return 0;
+    }
+
+    /**
+     * Sets the limit for number of ambient mobs that can spawn in a chunk in
+     * this world
+     * <p>
+     * <b>Note:</b> If set to a negative number the world will use the
+     * server-wide spawn limit instead.
+     *
+     * @param limit
+     */
+    @Override
+    public void setAmbientSpawnLimit(int limit) {
+
+    }
+
+    /**
+     * Play a Sound at the provided Location in the World
+     * <p>
+     * This function will fail silently if Location or Sound are null.
+     *
+     * @param location The location to play the sound
+     * @param sound    The sound to play
+     * @param volume   The volume of the sound
+     * @param pitch    The pitch of the sound
+     */
+    @Override
+    public void playSound(Location location, Sound sound, float volume, float pitch) {
+
+    }
+
+    /**
+     * Get existing rules
+     *
+     * @return An array of rules
+     */
+    @Override
+    public String[] getGameRules() {
+        return new String[0];
+    }
+
+    /**
+     * Gets the current state of the specified rule
+     * <p>
+     * Will return null if rule passed is null
+     *
+     * @param rule Rule to look up value of
+     * @return String value of rule
+     */
+    @Override
+    public String getGameRuleValue(String rule) {
+        return null;
+    }
+
+    /**
+     * Set the specified gamerule to specified value.
+     * <p>
+     * The rule may attempt to validate the value passed, will return true if
+     * value was set.
+     * <p>
+     * If rule is null, the function will return false.
+     *
+     * @param rule  Rule to set
+     * @param value Value to set rule to
+     * @return True if rule was set
+     */
+    @Override
+    public boolean setGameRuleValue(String rule, String value) {
+        return false;
+    }
+
+    /**
+     * Checks if string is a valid game rule
+     *
+     * @param rule Rule to check
+     * @return True if rule exists
+     */
+    @Override
+    public boolean isGameRule(String rule) {
+        return false;
+    }
+
+    /**
+     * Sets a metadata value in the implementing object's metadata store.
+     *
+     * @param metadataKey      A unique key to identify this metadata.
+     * @param newMetadataValue The metadata value to apply.
+     * @throws IllegalArgumentException If value is null, or the owning plugin
+     *                                  is null
+     */
+    @Override
+    public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
+
+    }
+
+    /**
+     * Returns a list of previously set metadata values from the implementing
+     * object's metadata store.
+     *
+     * @param metadataKey the unique metadata key being sought.
+     * @return A list of values, one for each plugin that has set the
+     * requested value.
+     */
+    @Override
+    public List<MetadataValue> getMetadata(String metadataKey) {
+        return null;
+    }
+
+    /**
+     * Tests to see whether the implementing object contains the given
+     * metadata value in its metadata store.
+     *
+     * @param metadataKey the unique metadata key being queried.
+     * @return the existence of the metadataKey within subject.
+     */
+    @Override
+    public boolean hasMetadata(String metadataKey) {
+        return false;
+    }
+
+    /**
+     * Removes the given metadata value from the implementing object's
+     * metadata store.
+     *
+     * @param metadataKey  the unique metadata key identifying the metadata to
+     *                     remove.
+     * @param owningPlugin This plugin's metadata value will be removed. All
+     *                     other values will be left untouched.
+     * @throws IllegalArgumentException If plugin is null
+     */
+    @Override
+    public void removeMetadata(String metadataKey, Plugin owningPlugin) {
+
+    }
+
+    /**
+     * Sends this recipient a Plugin Message on the specified outgoing
+     * channel.
+     * <p>
+     * The message may not be larger than {@link Messenger#MAX_MESSAGE_SIZE}
+     * bytes, and the plugin must be registered to send messages on the
+     * specified channel.
+     *
+     * @param source  The plugin that sent this message.
+     * @param channel The channel to send this message on.
+     * @param message The raw message to send.
+     * @throws IllegalArgumentException      Thrown if the source plugin is
+     *                                       disabled.
+     * @throws IllegalArgumentException      Thrown if source, channel or message
+     *                                       is null.
+     * @throws MessageTooLargeException      Thrown if the message is too big.
+     * @throws ChannelNotRegisteredException Thrown if the channel is not
+     *                                       registered for this plugin.
+     */
+    @Override
+    public void sendPluginMessage(Plugin source, String channel, byte[] message) {
+
+    }
+
+    /**
+     * Gets a set containing all the Plugin Channels that this client is
+     * listening on.
+     *
+     * @return Set containing all the channels that this client may accept.
+     */
+    @Override
+    public Set<String> getListeningPluginChannels() {
+        return null;
+    }
 }
