--- WorldGenBigTree.java
+++ WorldGenBigTree.java
@@ -5,4 +5,9 @@
 public class WorldGenBigTree extends WorldGenerator {
     static final byte[] otherCoordPairs;
+
+    static {
+        otherCoordPairs = new byte[]{2, 0, 0, 1, 2, 1};
+    }
+
     Random rand;
     World worldObj;
@@ -19,9 +24,5 @@
     int leafDistanceLimit;
     int[][] leafNodes;
-    
-    static {
-        otherCoordPairs = new byte[] { 2, 0, 0, 1, 2, 1 };
-    }
-    
+
     public WorldGenBigTree() {
         this.rand = new Random();
@@ -37,11 +38,11 @@
         this.leafDistanceLimit = 4;
     }
-    
+
     void generateLeafNodeList() {
-        this.height = (int)(this.heightLimit * this.heightAttenuation);
+        this.height = (int) (this.heightLimit * this.heightAttenuation);
         if (this.height >= this.heightLimit) {
             this.height = this.heightLimit - 1;
         }
-        int i1 = (int)(1.382 + Math.pow(this.leafDensity * this.heightLimit / 13.0, 2.0));
+        int i1 = (int) (1.382 + Math.pow(this.leafDensity * this.heightLimit / 13.0, 2.0));
         if (i1 < 1) {
             i1 = 1;
@@ -63,24 +64,22 @@
                 --i3;
                 --i6;
-            }
-            else {
+            } else {
                 final double d9 = 0.5;
                 while (i7 < i1) {
                     final double d10 = this.scaleWidth * f8 * (this.rand.nextFloat() + 0.328);
                     final double d11 = this.rand.nextFloat() * 2.0 * 3.14159;
-                    final int i8 = (int)(d10 * Math.sin(d11) + this.basePos[0] + d9);
-                    final int i9 = (int)(d10 * Math.cos(d11) + this.basePos[2] + d9);
-                    final int[] i10 = { i8, i3, i9 };
-                    final int[] i11 = { i8, i3 + this.leafDistanceLimit, i9 };
+                    final int i8 = (int) (d10 * Math.sin(d11) + this.basePos[0] + d9);
+                    final int i9 = (int) (d10 * Math.cos(d11) + this.basePos[2] + d9);
+                    final int[] i10 = {i8, i3, i9};
+                    final int[] i11 = {i8, i3 + this.leafDistanceLimit, i9};
                     if (this.checkBlockLine(i10, i11) == -1) {
-                        final int[] i12 = { this.basePos[0], this.basePos[1], this.basePos[2] };
-                        final double d12 = Math.sqrt(Math.pow((double)Math.abs(this.basePos[0] - i10[0]), 2.0) + Math.pow((double)Math.abs(this.basePos[2] - i10[2]), 2.0));
+                        final int[] i12 = {this.basePos[0], this.basePos[1], this.basePos[2]};
+                        final double d12 = Math.sqrt(Math.pow((double) Math.abs(this.basePos[0] - i10[0]), 2.0) + Math.pow((double) Math.abs(this.basePos[2] - i10[2]), 2.0));
                         final double d13 = d12 * this.branchSlope;
                         if (i10[1] - d13 > i5) {
                             i12[1] = i5;
+                        } else {
+                            i12[1] = (int) (i10[1] - d13);
                         }
-                        else {
-                            i12[1] = (int)(i10[1] - d13);
-                        }
                         if (this.checkBlockLine(i12, i10) == -1) {
                             i2[i4][0] = i8;
@@ -99,10 +98,10 @@
         System.arraycopy(i2, 0, (this.leafNodes = new int[i4][4]), 0, i4);
     }
-    
+
     void genTreeLayer(final int i1, final int i2, final int i3, final float f4, final byte b5, final int i6) {
-        final int i7 = (int)(f4 + 0.618);
+        final int i7 = (int) (f4 + 0.618);
         final byte b6 = WorldGenBigTree.otherCoordPairs[b5];
         final byte b7 = WorldGenBigTree.otherCoordPairs[b5 + 3];
-        final int[] i8 = { i1, i2, i3 };
+        final int[] i8 = {i1, i2, i3};
         final int[] i9 = new int[3];
         int i10 = -i7;
@@ -124,7 +123,7 @@
         }
     }
-    
+
     float layerSize(final int i1) {
-        if (i1 < (float)this.heightLimit * 0.3) {
+        if (i1 < (float) this.heightLimit * 0.3) {
             return -1.618f;
         }
@@ -134,26 +133,24 @@
         if (f3 == 0.0f) {
             f4 = f2;
-        }
-        else if (Math.abs(f3) >= f2) {
+        } else if (Math.abs(f3) >= f2) {
             f4 = 0.0f;
+        } else {
+            f4 = (float) Math.sqrt(Math.pow((double) Math.abs(f2), 2.0) - Math.pow((double) Math.abs(f3), 2.0));
         }
-        else {
-            f4 = (float)Math.sqrt(Math.pow((double)Math.abs(f2), 2.0) - Math.pow((double)Math.abs(f3), 2.0));
-        }
         f4 *= 0.5f;
         return f4;
     }
-    
+
     float leafSize(final int i1) {
         return (i1 >= 0 && i1 < this.leafDistanceLimit) ? ((i1 != 0 && i1 != this.leafDistanceLimit - 1) ? 3.0f : 2.0f) : -1.0f;
     }
-    
+
     void generateLeafNode(final int x, final int y, final int z) {
         for (int i4 = y, i5 = y + this.leafDistanceLimit; i4 < i5; ++i4) {
             final float f6 = this.leafSize(i4 - y);
-            this.genTreeLayer(x, i4, z, f6, (byte)1, 18);
+            this.genTreeLayer(x, i4, z, f6, (byte) 1, 18);
         }
     }
-    
+
     void placeBlockLine(final int[] i1, final int[] i2, final int i3) {
         final int[] i4 = new int[3];
@@ -173,10 +170,9 @@
             if (i4[b6] > 0) {
                 b9 = 1;
-            }
-            else {
+            } else {
                 b9 = -1;
             }
-            final double d10 = i4[b7] / (double)i4[b6];
-            final double d11 = i4[b8] / (double)i4[b6];
+            final double d10 = i4[b7] / (double) i4[b6];
+            final double d11 = i4[b8] / (double) i4[b6];
             final int[] i5 = new int[3];
             for (int i6 = 0, i7 = i4[b6] + b9; i6 != i7; i6 += b9) {
@@ -188,5 +184,5 @@
         }
     }
-    
+
     void generateLeaves() {
         for (int i1 = 0, i2 = this.leafNodes.length; i1 < i2; ++i1) {
@@ -197,9 +193,9 @@
         }
     }
-    
+
     boolean leafNodeNeedsBase(final int i1) {
         return i1 >= this.heightLimit * 0.2;
     }
-    
+
     void generateTrunk() {
         final int i1 = this.basePos[0];
@@ -207,6 +203,6 @@
         final int i3 = this.basePos[1] + this.height;
         final int i4 = this.basePos[2];
-        final int[] i5 = { i1, i2, i4 };
-        final int[] i6 = { i1, i3, i4 };
+        final int[] i5 = {i1, i2, i4};
+        final int[] i6 = {i1, i3, i4};
         this.placeBlockLine(i5, i6, 17);
         if (this.trunkSize == 2) {
@@ -234,12 +230,12 @@
         }
     }
-    
+
     void generateLeafNodeBases() {
         int i1 = 0;
         final int i2 = this.leafNodes.length;
-        final int[] i3 = { this.basePos[0], this.basePos[1], this.basePos[2] };
+        final int[] i3 = {this.basePos[0], this.basePos[1], this.basePos[2]};
         while (i1 < i2) {
             final int[] i4 = this.leafNodes[i1];
-            final int[] i5 = { i4[0], i4[1], i4[2] };
+            final int[] i5 = {i4[0], i4[1], i4[2]};
             i3[1] = i4[3];
             final int i6 = i3[1] - this.basePos[1];
@@ -250,5 +246,5 @@
         }
     }
-    
+
     int checkBlockLine(final int[] i1, final int[] i2) {
         final int[] i3 = new int[3];
@@ -270,10 +266,9 @@
         if (i3[b5] > 0) {
             b8 = 1;
-        }
-        else {
+        } else {
             b8 = -1;
         }
-        final double d9 = i3[b6] / (double)i3[b5];
-        final double d10 = i3[b7] / (double)i3[b5];
+        final double d9 = i3[b6] / (double) i3[b5];
+        final double d10 = i3[b7] / (double) i3[b5];
         final int[] i4 = new int[3];
         int i5;
@@ -281,6 +276,6 @@
         for (i5 = 0, i6 = i3[b5] + b8; i5 != i6; i5 += b8) {
             i4[b5] = i1[b5] + i5;
-            i4[b6] = (int)(i1[b6] + i5 * d9);
-            i4[b7] = (int)(i1[b7] + i5 * d10);
+            i4[b6] = (int) (i1[b6] + i5 * d9);
+            i4[b7] = (int) (i1[b7] + i5 * d10);
             final int i7 = this.worldObj.getBlockId(i4[0], i4[1], i4[2]);
             if (i7 != 0 && i7 != 18) {
@@ -290,8 +285,8 @@
         return (i5 == i6) ? -1 : Math.abs(i5);
     }
-    
+
     boolean validTreeLocation() {
-        final int[] i1 = { this.basePos[0], this.basePos[1], this.basePos[2] };
-        final int[] i2 = { this.basePos[0], this.basePos[1] + this.heightLimit - 1, this.basePos[2] };
+        final int[] i1 = {this.basePos[0], this.basePos[1], this.basePos[2]};
+        final int[] i2 = {this.basePos[0], this.basePos[1] + this.heightLimit - 1, this.basePos[2]};
         final int i3 = this.worldObj.getBlockId(this.basePos[0], this.basePos[1] - 1, this.basePos[2]);
         if (i3 != 2 && i3 != 3) {
@@ -308,8 +303,8 @@
         return true;
     }
-    
+
     @Override
     public void setScale(final double scaleX, final double scaleY, final double scaleZ) {
-        this.heightLimitLimit = (int)(scaleX * 12.0);
+        this.heightLimitLimit = (int) (scaleX * 12.0);
         if (scaleX > 0.5) {
             this.leafDistanceLimit = 5;
@@ -318,5 +313,5 @@
         this.leafDensity = scaleZ;
     }
-    
+
     @Override
     public boolean generate(final World world, final Random rand, final int x, final int y, final int z) {
