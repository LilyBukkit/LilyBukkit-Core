--- EntityBoat.java
+++ EntityBoat.java
@@ -1,11 +1,18 @@
 package net.minecraft.src;
 
+import org.bukkit.Location;
+import org.bukkit.Server;
+import org.bukkit.entity.Boat;
+import org.bukkit.event.entity.EntityDamageEvent;
+import org.bukkit.util.Vector;
+
 import java.util.List;
+import java.util.UUID;
 
-public class EntityBoat extends Entity {
+public class EntityBoat extends Entity implements Boat {
     public int damageTaken;
     public int timeSinceHit;
     public int forwardDirection;
-    
+
     public EntityBoat(final World world) {
         super(world);
@@ -18,25 +25,25 @@
         this.canTriggerWalking = false;
     }
-    
+
     @Override
     public AxisAlignedBB getCollisionBox(final Entity entity) {
         return entity.boundingBox;
     }
-    
+
     @Override
     public AxisAlignedBB getBoundingBox() {
         return this.boundingBox;
     }
-    
+
     @Override
     public boolean canBePushed() {
         return true;
     }
-    
+
     @Override
     public double getMountedYOffset() {
         return this.height * 0.0 - 0.30000001192092896;
     }
-    
+
     @Override
     public boolean attackEntityFrom(final Entity entity, final int damage) {
@@ -55,10 +62,10 @@
         return true;
     }
-    
+
     @Override
     public boolean canBeCollidedWith() {
         return !this.isDead;
     }
-    
+
     @Override
     public void onUpdate() {
@@ -119,6 +126,5 @@
                     final double d13 = this.posZ - d9 * d10 * 0.8 - d8 * d11;
                     this.worldObj.spawnParticle("splash", d12, this.posY - 0.125, d13, this.motionX, this.motionY, this.motionZ);
-                }
-                else {
+                } else {
                     final double d12 = this.posX + d8 + d9 * d10 * 0.7;
                     final double d13 = this.posZ + d9 - d8 * d10 * 0.7;
@@ -135,6 +141,5 @@
                 this.entityDropItem(Item.stick.shiftedIndex, 1, 0.0f);
             }
-        }
-        else {
+        } else {
             this.motionX *= 0.9900000095367432;
             this.motionY *= 0.949999988079071;
@@ -146,8 +151,9 @@
         final double d14 = this.prevPosZ - this.posZ;
         if (d9 * d9 + d14 * d14 > 0.001) {
-            d8 = (float)(Math.atan2(d14, d9) * 180.0 / 3.141592653589793);
+            d8 = (float) (Math.atan2(d14, d9) * 180.0 / 3.141592653589793);
         }
         double d15;
-        for (d15 = d8 - this.rotationYaw; d15 >= 180.0; d15 -= 360.0) {}
+        for (d15 = d8 - this.rotationYaw; d15 >= 180.0; d15 -= 360.0) {
+        }
         while (d15 < -180.0) {
             d15 += 360.0;
@@ -159,9 +165,9 @@
             d15 = -20.0;
         }
-        this.setRotation(this.rotationYaw += (float)d15, this.rotationPitch);
+        this.setRotation(this.rotationYaw += (float) d15, this.rotationPitch);
         final List list18 = this.worldObj.getEntitiesWithinAABBExcludingEntity(this, this.boundingBox.expand(0.20000000298023224, 0.0, 0.20000000298023224));
         if (list18 != null && list18.size() > 0) {
             for (int i7 = 0; i7 < list18.size(); ++i7) {
-                final Entity entity20 = (Entity)list18.get(i7);
+                final Entity entity20 = (Entity) list18.get(i7);
                 if (entity20 != this.riddenByEntity && entity20.canBePushed() && entity20 instanceof EntityBoat) {
                     entity20.applyEntityCollision(this);
@@ -173,5 +179,5 @@
         }
     }
-    
+
     @Override
     protected void updateRiderPosition() {
@@ -180,11 +186,262 @@
         this.riddenByEntity.setPosition(this.posX + d1, this.posY + this.getMountedYOffset() + this.riddenByEntity.getYOffset(), this.posZ + d2);
     }
-    
+
     @Override
     protected void writeEntityToNBT(final NBTTagCompound nbttagcompound) {
     }
-    
+
     @Override
     protected void readEntityFromNBT(final NBTTagCompound nbttagcompound) {
     }
+
+    /**
+     * Gets the maximum speed of a boat. The speed is unrelated to the velocity.
+     */
+    @Override
+    public double getMaxSpeed() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets the maximum speed of a boat. Must be nonnegative. Default is 0.4D.
+     *
+     * @param speed
+     */
+    @Override
+    public void setMaxSpeed(double speed) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the entity's current position
+     *
+     * @return Location containing the position of this entity
+     */
+    @Override
+    public Location getLocation() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets this entity's current velocity
+     *
+     * @return Current travelling velocity of this entity
+     */
+    @Override
+    public Vector getVelocity() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets this entity's velocity
+     *
+     * @param velocity New velocity to travel with
+     */
+    @Override
+    public void setVelocity(Vector velocity) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the current world this entity resides in
+     *
+     * @return World
+     */
+    @Override
+    public org.bukkit.World getWorld() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Teleports this entity to the given location
+     *
+     * @param location New location to teleport this entity to
+     * @return <code>true</code> if the teleport was successful
+     */
+    @Override
+    public boolean teleport(Location location) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Teleports this entity to the target Entity
+     *
+     * @param destination Entity to teleport this entity to
+     * @return <code>true</code> if the teleport was successful
+     */
+    @Override
+    public boolean teleport(org.bukkit.entity.Entity destination) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns a list of entities within a bounding box defined by x,y,z centered around player
+     *
+     * @param x Size of the box along x axis
+     * @param y Size of the box along y axis
+     * @param z Size of the box along z axis
+     * @return List<Entity> List of entities nearby
+     */
+    @Override
+    public List<org.bukkit.entity.Entity> getNearbyEntities(double x, double y, double z) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns a unique id for this entity
+     *
+     * @return Entity id
+     */
+    @Override
+    public int getEntityId() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns the entity's current fire ticks (ticks before the entity stops being on fire).
+     *
+     * @return int fireTicks
+     */
+    @Override
+    public int getFireTicks() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets the entity's current fire ticks (ticks before the entity stops being on fire).
+     *
+     * @param ticks
+     */
+    @Override
+    public void setFireTicks(int ticks) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns the entity's maximum fire ticks.
+     *
+     * @return int maxFireTicks
+     */
+    @Override
+    public int getMaxFireTicks() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Mark the entity's removal.
+     */
+    @Override
+    public void remove() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns true if this entity has been marked for removal.
+     */
+    @Override
+    public boolean isDead() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the {@link Server} that contains this Entity
+     *
+     * @return Server instance running this Entity
+     */
+    @Override
+    public Server getServer() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the primary passenger of a vehicle. For vehicles that could have
+     * multiple passengers, this will only return the primary passenger.
+     *
+     * @return an entity
+     */
+    @Override
+    public org.bukkit.entity.Entity getPassenger() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Set the passenger of a vehicle.
+     *
+     * @param passenger
+     * @return false if it could not be done for whatever reason
+     */
+    @Override
+    public boolean setPassenger(org.bukkit.entity.Entity passenger) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns true if the vehicle has no passengers.
+     *
+     * @return
+     */
+    @Override
+    public boolean isEmpty() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Eject any passenger. True if there was a passenger.
+     *
+     * @return
+     */
+    @Override
+    public boolean eject() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns the distance this entity has fallen
+     *
+     * @return
+     */
+    @Override
+    public float getFallDistance() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets the fall distance for this entity
+     *
+     * @param distance
+     */
+    @Override
+    public void setFallDistance(float distance) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Retrieve the last {@link EntityDamageEvent} inflicted on this entity. This event may have been cancelled.
+     *
+     * @return the last known {@link EntityDamageEvent} or null if hitherto unharmed
+     */
+    @Override
+    public EntityDamageEvent getLastDamageCause() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Record the last {@link EntityDamageEvent} inflicted on this entity
+     *
+     * @param event a {@link EntityDamageEvent}
+     */
+    @Override
+    public void setLastDamageCause(EntityDamageEvent event) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns a unique and persistent id for this entity
+     *
+     * @return unique id
+     */
+    @Override
+    public UUID getUniqueId() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
 }
