--- Block.java
+++ Block.java
@@ -1,8 +1,15 @@
 package net.minecraft.src;
 
-import java.util.Random;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.block.Biome;
+import org.bukkit.block.BlockFace;
+import org.bukkit.block.BlockState;
+import org.bukkit.block.PistonMoveReaction;
+
 import java.util.ArrayList;
+import java.util.Random;
 
-public class Block {
+public class Block implements org.bukkit.block.Block {
     public static final StepSound soundPowderFootstep;
     public static final StepSound soundWoodFootstep;
@@ -106,18 +113,4 @@
     public static final Block jukebox;
     public static final Block fence;
-    public int blockIndexInTexture;
-    public final int blockID;
-    protected float hardness;
-    protected float resistance;
-    public double minX;
-    public double minY;
-    public double minZ;
-    public double maxX;
-    public double maxY;
-    public double maxZ;
-    public StepSound stepSound;
-    public float blockParticleGravity;
-    public final Material material;
-    public float slipperiness;
     public static final Block QuadWindowGlassBlock;
     public static final Block PillarBlock;
@@ -151,5 +144,5 @@
     public static final Block blueFireIdk;
     public static final Block safe;
-    
+
     static {
         soundPowderFootstep = new StepSound("stone", 1.0f, 1.0f);
@@ -170,5 +163,5 @@
         lightValue = new int[256];
         stone = new BlockStone(1, 1).setHardness(1.5f).setResistance(10.0f).setStepSound(Block.soundStoneFootstep);
-        grass = (BlockGrass)new BlockGrass(2).setHardness(0.6f).setStepSound(Block.soundGrassFootstep);
+        grass = (BlockGrass) new BlockGrass(2).setHardness(0.6f).setStepSound(Block.soundGrassFootstep);
         dirt = new BlockDirt(3, 2).setHardness(0.5f).setStepSound(Block.soundGravelFootstep);
         cobblestone = new Block(4, 16, Material.rock).setHardness(2.0f).setResistance(10.0f).setStepSound(Block.soundStoneFootstep);
@@ -186,5 +179,5 @@
         oreCoal = new BlockOre(16, 34).setHardness(3.0f).setResistance(5.0f).setStepSound(Block.soundStoneFootstep);
         wood = new BlockLog(17).setHardness(2.0f).setStepSound(Block.soundWoodFootstep);
-        leaves = (BlockLeaves)new BlockLeaves(18, 52).setHardness(0.2f).setLightOpacity(1).setStepSound(Block.soundGrassFootstep);
+        leaves = (BlockLeaves) new BlockLeaves(18, 52).setHardness(0.2f).setLightOpacity(1).setStepSound(Block.soundGrassFootstep);
         sponge = new BlockSponge(19).setHardness(0.6f).setStepSound(Block.soundGrassFootstep);
         glass = new BlockGlass(20, 49, Material.glass, false).setHardness(0.3f).setStepSound(Block.soundGlassFootstep);
@@ -205,8 +198,8 @@
         cloth = new Block(35, 64, Material.cloth).setHardness(0.8f).setStepSound(Block.soundClothFootstep);
         clothWhite = null;
-        plantYellow = (BlockFlower)new BlockFlower(37, 13).setHardness(0.0f).setStepSound(Block.soundGrassFootstep);
-        plantRed = (BlockFlower)new BlockFlower(38, 12).setHardness(0.0f).setStepSound(Block.soundGrassFootstep);
-        mushroomBrown = (BlockFlower)new BlockMushroom(39, 29).setHardness(0.0f).setStepSound(Block.soundGrassFootstep).setLightValue(0.125f);
-        mushroomRed = (BlockFlower)new BlockMushroom(40, 28).setHardness(0.0f).setStepSound(Block.soundGrassFootstep);
+        plantYellow = (BlockFlower) new BlockFlower(37, 13).setHardness(0.0f).setStepSound(Block.soundGrassFootstep);
+        plantRed = (BlockFlower) new BlockFlower(38, 12).setHardness(0.0f).setStepSound(Block.soundGrassFootstep);
+        mushroomBrown = (BlockFlower) new BlockMushroom(39, 29).setHardness(0.0f).setStepSound(Block.soundGrassFootstep).setLightValue(0.125f);
+        mushroomRed = (BlockFlower) new BlockMushroom(40, 28).setHardness(0.0f).setStepSound(Block.soundGrassFootstep);
         blockGold = new BlockOreBlock(41, 39).setHardness(3.0f).setResistance(10.0f).setStepSound(Block.soundMetalFootstep);
         blockSteel = new BlockOreBlock(42, 38).setHardness(5.0f).setResistance(10.0f).setStepSound(Block.soundMetalFootstep);
@@ -219,5 +212,5 @@
         obsidian = new BlockObsidian(49, 37).setHardness(10.0f).setResistance(2000.0f).setStepSound(Block.soundStoneFootstep);
         torch = new BlockTorch(50, 80).setHardness(0.0f).setLightValue(0.9375f).setStepSound(Block.soundWoodFootstep);
-        fire = (BlockFire)new BlockFire(51, 31).setHardness(0.0f).setLightValue(1.0f).setStepSound(Block.soundWoodFootstep);
+        fire = (BlockFire) new BlockFire(51, 31).setHardness(0.0f).setLightValue(1.0f).setStepSound(Block.soundWoodFootstep);
         mobSpawner = new BlockMobSpawner(52, 65).setHardness(5.0f).setStepSound(Block.soundMetalFootstep);
         stairCompactWood = new BlockStairs(53, Block.planks);
@@ -291,5 +284,20 @@
         }
     }
-    
+
+    public final int blockID;
+    public final Material material;
+    public int blockIndexInTexture;
+    public double minX;
+    public double minY;
+    public double minZ;
+    public double maxX;
+    public double maxY;
+    public double maxZ;
+    public StepSound stepSound;
+    public float blockParticleGravity;
+    public float slipperiness;
+    protected float hardness;
+    protected float resistance;
+
     protected Block(final int id, final Material material) {
         this.stepSound = Block.soundPowderFootstep;
@@ -308,38 +316,38 @@
         Block.isBlockContainer[id] = false;
     }
-    
+
     protected Block(final int id, final int blockIndex, final Material material) {
         this(id, material);
         this.blockIndexInTexture = blockIndex;
     }
-    
+
     protected Block setStepSound(final StepSound stepSound) {
         this.stepSound = stepSound;
         return this;
     }
-    
+
     protected Block setLightOpacity(final int opacity) {
         Block.lightOpacity[this.blockID] = opacity;
         return this;
     }
-    
+
     protected Block setLightValue(final float value) {
-        Block.lightValue[this.blockID] = (int)(15.0f * value);
+        Block.lightValue[this.blockID] = (int) (15.0f * value);
         return this;
     }
-    
+
     protected Block setResistance(final float resistance) {
         this.resistance = resistance * 3.0f;
         return this;
     }
-    
+
     private boolean getCanBlockGrass() {
         return false;
     }
-    
+
     public int getRenderType() {
         return 0;
     }
-    
+
     protected Block setHardness(final float hardness) {
         this.hardness = hardness;
@@ -349,9 +357,9 @@
         return this;
     }
-    
+
     protected void setTickOnLoad(final boolean doesTickOnLoad) {
         Block.tickOnLoad[this.blockID] = doesTickOnLoad;
     }
-    
+
     public void setBlockBounds(final float minX, final float minY, final float minZ, final float maxX, final float maxY, final float maxZ) {
         this.minX = minX;
@@ -362,21 +370,21 @@
         this.maxZ = maxZ;
     }
-    
+
     public boolean shouldSideBeRendered(final IBlockAccess blockAccess, final int x, final int y, final int z, final int side) {
         return (side == 0 && this.minY > 0.0) || (side == 1 && this.maxY < 1.0) || (side == 2 && this.minZ > 0.0) || (side == 3 && this.maxZ < 1.0) || (side == 4 && this.minX > 0.0) || (side == 5 && this.maxX < 1.0) || !blockAccess.isBlockNormalCube(x, y, z);
     }
-    
+
     public int getBlockTextureFromSide(final int side) {
         return this.blockIndexInTexture;
     }
-    
+
     public int getBlockTexture(final IBlockAccess iBlockAccess, final int n, final int n2, final int n3, final int n4) {
         return this.getBlockTextureFromSideAndMetadata(n4, iBlockAccess.getBlockMetadata(n, n2, n3));
     }
-    
+
     public int getBlockTextureFromSideAndMetadata(final int n, final int n2) {
         return this.getBlockTextureFromSide(n);
     }
-    
+
     public void getCollidingBoundingBoxes(final World world, final int x, final int y, final int z, final AxisAlignedBB aabb, final ArrayList arrayList) {
         final AxisAlignedBB axisAlignedBB7 = this.getCollisionBoundingBoxFromPool(world, x, y, z);
@@ -385,48 +393,48 @@
         }
     }
-    
+
     public AxisAlignedBB getCollisionBoundingBoxFromPool(final World world, final int x, final int y, final int z) {
         return AxisAlignedBB.getBoundingBoxFromPool(x + this.minX, y + this.minY, z + this.minZ, x + this.maxX, y + this.maxY, z + this.maxZ);
     }
-    
+
     public boolean isOpaqueCube() {
         return true;
     }
-    
+
     public boolean canCollideCheck(final int i1, final boolean z2) {
         return this.isCollidable();
     }
-    
+
     public boolean isCollidable() {
         return true;
     }
-    
+
     public void updateTick(final World world, final int x, final int y, final int z, final Random random) {
     }
-    
+
     public void onBlockDestroyedByPlayer(final World world, final int x, final int y, final int z, final int flag) {
     }
-    
+
     public void onNeighborBlockChange(final World world, final int x, final int y, final int z, final int flag) {
     }
-    
+
     public int tickRate() {
         return 10;
     }
-    
+
     public void onBlockAdded(final World world, final int x, final int y, final int z) {
     }
-    
+
     public void onBlockRemoval(final World world, final int x, final int y, final int z) {
     }
-    
+
     public int quantityDropped(final Random random) {
         return 1;
     }
-    
+
     public int idDropped(final int count, final Random random) {
         return this.blockID;
     }
-    
+
     public float blockStrength(final EntityPlayer entityPlayer) {
         if (this.hardness < 0.0f) {
@@ -435,6 +443,5 @@
             }
             return 0.0f;
-        }
-        else {
+        } else {
             if (!entityPlayer.canHarvestBlock(this)) {
                 return 1.0f / this.hardness / 100.0f;
@@ -443,9 +450,9 @@
         }
     }
-    
+
     public void dropBlockAsItem(final World world, final int i2, final int i3, final int i4, final int i5) {
         this.dropBlockAsItemWithChance(world, i2, i3, i4, i5, 1.0f);
     }
-    
+
     public void dropBlockAsItemWithChance(final World world, final int x, final int y, final int z, final int i5, final float f6) {
         if (!world.multiplayerWorld) {
@@ -466,9 +473,9 @@
         }
     }
-    
+
     public float getExplosionResistance(final Entity entity) {
         return this.resistance / 5.0f;
     }
-    
+
     public MovingObjectPosition collisionRayTrace(final World world, final int x, final int y, final int z, Vec3D vector1, Vec3D vector2) {
         this.setBlockBoundsBasedOnState(world, x, y, z);
@@ -542,61 +549,435 @@
         return new MovingObjectPosition(x, y, z, b14, vec3D13.addVector(x, y, z));
     }
-    
+
     private boolean isVecInsideYZBounds(final Vec3D vector) {
         return vector != null && (vector.yCoord >= this.minY && vector.yCoord <= this.maxY && vector.zCoord >= this.minZ && vector.zCoord <= this.maxZ);
     }
-    
+
     private boolean isVecInsideXZBounds(final Vec3D vector) {
         return vector != null && (vector.xCoord >= this.minX && vector.xCoord <= this.maxX && vector.zCoord >= this.minZ && vector.zCoord <= this.maxZ);
     }
-    
+
     private boolean isVecInsideXYBounds(final Vec3D vector) {
         return vector != null && (vector.xCoord >= this.minX && vector.xCoord <= this.maxX && vector.yCoord >= this.minY && vector.yCoord <= this.maxY);
     }
-    
+
     public void onBlockDestroyedByExplosion(final World world, final int x, final int y, final int z) {
     }
-    
+
     public boolean canPlaceBlockAt(final World world, final int x, final int y, final int z) {
         final int i5 = world.getBlockId(x, y, z);
         return i5 == 0 || Block.blocksList[i5].material.getIsLiquid();
     }
-    
+
     public boolean blockActivated(final World world, final int x, final int y, final int z, final EntityPlayer entityPlayer) {
         return false;
     }
-    
+
     public void onEntityWalking(final World world, final int x, final int y, final int z, final Entity entity) {
     }
-    
+
     public void onBlockPlaced(final World world, final int x, final int y, final int z, final int notifyFlag) {
     }
-    
+
     public void onBlockClicked(final World world, final int x, final int y, final int z, final EntityPlayer entityPlayer) {
     }
-    
+
     public void velocityToAddToEntity(final World world, final int x, final int y, final int z, final Entity entity, final Vec3D vector) {
     }
-    
+
     public void setBlockBoundsBasedOnState(final IBlockAccess blockAccess, final int x, final int y, final int z) {
     }
-    
+
     public boolean isPoweringTo(final IBlockAccess blockAccess, final int x, final int y, final int z, final int unused) {
         return false;
     }
-    
+
     public boolean canProvidePower() {
         return false;
     }
-    
+
     public void onEntityCollidedWithBlock(final World world, final int x, final int y, final int z, final Entity entity) {
     }
-    
+
     public boolean isIndirectlyPoweringTo(final World world, final int x, final int y, final int z, final int flag) {
         return false;
     }
-    
+
     public boolean canBlockStay(final World world, final int x, final int y, final int z) {
         return true;
     }
+
+    /**
+     * Gets the metadata for this block
+     *
+     * @return block specific metadata
+     */
+    @Override
+    public byte getData() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets the metadata for this block
+     *
+     * @param data New block specific metadata
+     */
+    @Override
+    public void setData(byte data) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * @param face
+     * @deprecated use {@link #getRelative(BlockFace face)}
+     */
+    @Override
+    public org.bukkit.block.Block getFace(BlockFace face) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * @param face
+     * @param distance
+     * @deprecated use {@link #getRelative(BlockFace face, int distance)}
+     */
+    @Override
+    public org.bukkit.block.Block getFace(BlockFace face, int distance) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the block at the given offsets
+     *
+     * @param modX X-coordinate offset
+     * @param modY Y-coordinate offset
+     * @param modZ Z-coordinate offset
+     * @return Block at the given offsets
+     */
+    @Override
+    public org.bukkit.block.Block getRelative(int modX, int modY, int modZ) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the block at the given face<br />
+     * <br />
+     * This method is equal to getRelative(face, 1)
+     *
+     * @param face Face of this block to return
+     * @return Block at the given face
+     * @see org.bukkit.block.Block#getRelative(BlockFace face, int distance);
+     */
+    @Override
+    public org.bukkit.block.Block getRelative(BlockFace face) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the block at the given distance of the given face<br />
+     * <br />
+     * For example, the following method places water at 100,102,100; two blocks
+     * above 100,100,100.
+     * <pre>
+     * Block block = world.getBlockAt(100,100,100);
+     * Block shower = block.getFace(BlockFace.UP, 2);
+     * shower.setType(Material.WATER);
+     * </pre>
+     *
+     * @param face     Face of this block to return
+     * @param distance Distance to get the block at
+     * @return Block at the given face
+     */
+    @Override
+    public org.bukkit.block.Block getRelative(BlockFace face, int distance) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the type of this block
+     *
+     * @return block type
+     */
+    @Override
+    public org.bukkit.Material getType() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets the type of this block
+     *
+     * @param type Material to change this block to
+     */
+    @Override
+    public void setType(org.bukkit.Material type) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the type-id of this block
+     *
+     * @return block type-id
+     */
+    @Override
+    public int getTypeId() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the light level between 0-15
+     *
+     * @return light level
+     */
+    @Override
+    public byte getLightLevel() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the world which contains this Block
+     *
+     * @return World containing this block
+     */
+    @Override
+    public org.bukkit.World getWorld() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the x-coordinate of this block
+     *
+     * @return x-coordinate
+     */
+    @Override
+    public int getX() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the y-coordinate of this block
+     *
+     * @return y-coordinate
+     */
+    @Override
+    public int getY() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the z-coordinate of this block
+     *
+     * @return z-coordinate
+     */
+    @Override
+    public int getZ() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the Location of the block
+     *
+     * @return Location of block
+     */
+    @Override
+    public Location getLocation() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the chunk which contains this block
+     *
+     * @return Containing Chunk
+     */
+    @Override
+    public Chunk getChunk() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    @Override
+    public void setData(byte data, boolean applyPhyiscs) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Sets the type-id of this block
+     *
+     * @param type Type-Id to change this block to
+     * @return whether the block was changed
+     */
+    @Override
+    public boolean setTypeId(int type) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    @Override
+    public boolean setTypeId(int type, boolean applyPhysics) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    @Override
+    public boolean setTypeIdAndData(int type, byte data, boolean applyPhyiscs) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the face relation of this block compared to the given block<br />
+     * <br />
+     * For example:
+     * <pre>
+     * Block current = world.getBlockAt(100, 100, 100);
+     * Block target = world.getBlockAt(100, 101, 100);
+     *
+     * current.getFace(target) == BlockFace.Up;
+     * </pre>
+     * <br />
+     * If the given block is not connected to this block, null may be returned
+     *
+     * @param block Block to compare against this block
+     * @return BlockFace of this block which has the requested block, or null
+     */
+    @Override
+    public BlockFace getFace(org.bukkit.block.Block block) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Captures the current state of this block. You may then cast that state
+     * into any accepted type, such as Furnace or Sign.
+     * <p>
+     * The returned object will never be updated, and you are not guaranteed that
+     * (for example) a sign is still a sign after you capture its state.
+     *
+     * @return BlockState with the current state of this block.
+     */
+    @Override
+    public BlockState getState() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns the biome that this block resides in
+     *
+     * @return Biome type containing this block
+     */
+    @Override
+    public Biome getBiome() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns true if the block is being powered by Redstone.
+     *
+     * @return
+     */
+    @Override
+    public boolean isBlockPowered() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns true if the block is being indirectly powered by Redstone.
+     *
+     * @return
+     */
+    @Override
+    public boolean isBlockIndirectlyPowered() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns true if the block face is being powered by Redstone.
+     *
+     * @param face
+     * @return
+     */
+    @Override
+    public boolean isBlockFacePowered(BlockFace face) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns true if the block face is being indirectly powered by Redstone.
+     *
+     * @param face
+     * @return
+     */
+    @Override
+    public boolean isBlockFaceIndirectlyPowered(BlockFace face) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns the redstone power being provided to this block face
+     *
+     * @param face the face of the block to query or BlockFace.SELF for the block itself
+     * @return
+     */
+    @Override
+    public int getBlockPower(BlockFace face) {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns the redstone power being provided to this block
+     *
+     * @return
+     */
+    @Override
+    public int getBlockPower() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Checks if this block is empty.
+     * <p>
+     * A block is considered empty when {@link #getType()} returns {@link org.bukkit.Material#AIR}.
+     *
+     * @return true if this block is empty
+     */
+    @Override
+    public boolean isEmpty() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Checks if this block is liquid.
+     * <p>
+     * A block is considered liquid when {@link #getType()} returns {@link org.bukkit.Material#WATER}, {@link org.bukkit.Material#STATIONARY_WATER}, {@link org.bukkit.Material#LAVA} or {@link org.bukkit.Material#STATIONARY_LAVA}.
+     *
+     * @return true if this block is liquid
+     */
+    @Override
+    public boolean isLiquid() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the temperature of the biome of this block
+     *
+     * @return Temperature of this block
+     */
+    @Override
+    public double getTemperature() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Gets the humidity of the biome of this block
+     *
+     * @return Humidity of this block
+     */
+    @Override
+    public double getHumidity() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
+
+    /**
+     * Returns the reaction of the block when moved by a piston
+     *
+     * @return reaction
+     */
+    @Override
+    public PistonMoveReaction getPistonMoveReaction() {
+        throw new UnsupportedOperationException("Not implemented yet");
+    }
 }
