--- Block.java
+++ Block.java
@@ -1,6 +1,6 @@
 package net.minecraft.src;
 
-import java.util.Random;
 import java.util.ArrayList;
+import java.util.Random;
 
 public class Block {
@@ -151,5 +151,5 @@
     public static final Block blueFireIdk;
     public static final Block safe;
-    
+
     static {
         soundPowderFootstep = new StepSound("stone", 1.0f, 1.0f);
@@ -170,5 +170,5 @@
         lightValue = new int[256];
         stone = new BlockStone(1, 1).setHardness(1.5f).setResistance(10.0f).setStepSound(Block.soundStoneFootstep);
-        grass = (BlockGrass)new BlockGrass(2).setHardness(0.6f).setStepSound(Block.soundGrassFootstep);
+        grass = (BlockGrass) new BlockGrass(2).setHardness(0.6f).setStepSound(Block.soundGrassFootstep);
         dirt = new BlockDirt(3, 2).setHardness(0.5f).setStepSound(Block.soundGravelFootstep);
         cobblestone = new Block(4, 16, Material.rock).setHardness(2.0f).setResistance(10.0f).setStepSound(Block.soundStoneFootstep);
@@ -186,5 +186,5 @@
         oreCoal = new BlockOre(16, 34).setHardness(3.0f).setResistance(5.0f).setStepSound(Block.soundStoneFootstep);
         wood = new BlockLog(17).setHardness(2.0f).setStepSound(Block.soundWoodFootstep);
-        leaves = (BlockLeaves)new BlockLeaves(18, 52).setHardness(0.2f).setLightOpacity(1).setStepSound(Block.soundGrassFootstep);
+        leaves = (BlockLeaves) new BlockLeaves(18, 52).setHardness(0.2f).setLightOpacity(1).setStepSound(Block.soundGrassFootstep);
         sponge = new BlockSponge(19).setHardness(0.6f).setStepSound(Block.soundGrassFootstep);
         glass = new BlockGlass(20, 49, Material.glass, false).setHardness(0.3f).setStepSound(Block.soundGlassFootstep);
@@ -205,8 +205,8 @@
         cloth = new Block(35, 64, Material.cloth).setHardness(0.8f).setStepSound(Block.soundClothFootstep);
         clothWhite = null;
-        plantYellow = (BlockFlower)new BlockFlower(37, 13).setHardness(0.0f).setStepSound(Block.soundGrassFootstep);
-        plantRed = (BlockFlower)new BlockFlower(38, 12).setHardness(0.0f).setStepSound(Block.soundGrassFootstep);
-        mushroomBrown = (BlockFlower)new BlockMushroom(39, 29).setHardness(0.0f).setStepSound(Block.soundGrassFootstep).setLightValue(0.125f);
-        mushroomRed = (BlockFlower)new BlockMushroom(40, 28).setHardness(0.0f).setStepSound(Block.soundGrassFootstep);
+        plantYellow = (BlockFlower) new BlockFlower(37, 13).setHardness(0.0f).setStepSound(Block.soundGrassFootstep);
+        plantRed = (BlockFlower) new BlockFlower(38, 12).setHardness(0.0f).setStepSound(Block.soundGrassFootstep);
+        mushroomBrown = (BlockFlower) new BlockMushroom(39, 29).setHardness(0.0f).setStepSound(Block.soundGrassFootstep).setLightValue(0.125f);
+        mushroomRed = (BlockFlower) new BlockMushroom(40, 28).setHardness(0.0f).setStepSound(Block.soundGrassFootstep);
         blockGold = new BlockOreBlock(41, 39).setHardness(3.0f).setResistance(10.0f).setStepSound(Block.soundMetalFootstep);
         blockSteel = new BlockOreBlock(42, 38).setHardness(5.0f).setResistance(10.0f).setStepSound(Block.soundMetalFootstep);
@@ -219,5 +219,5 @@
         obsidian = new BlockObsidian(49, 37).setHardness(10.0f).setResistance(2000.0f).setStepSound(Block.soundStoneFootstep);
         torch = new BlockTorch(50, 80).setHardness(0.0f).setLightValue(0.9375f).setStepSound(Block.soundWoodFootstep);
-        fire = (BlockFire)new BlockFire(51, 31).setHardness(0.0f).setLightValue(1.0f).setStepSound(Block.soundWoodFootstep);
+        fire = (BlockFire) new BlockFire(51, 31).setHardness(0.0f).setLightValue(1.0f).setStepSound(Block.soundWoodFootstep);
         mobSpawner = new BlockMobSpawner(52, 65).setHardness(5.0f).setStepSound(Block.soundMetalFootstep);
         stairCompactWood = new BlockStairs(53, Block.planks);
@@ -291,5 +291,5 @@
         }
     }
-    
+
     protected Block(final int id, final Material material) {
         this.stepSound = Block.soundPowderFootstep;
@@ -297,5 +297,5 @@
         this.slipperiness = 0.6f;
         if (Block.blocksList[id] != null) {
-            throw new IllegalArgumentException(new StringBuilder("Slot ").append(id).append(" is already occupied by ").append(Block.blocksList[id]).append(" when adding ").append(this).toString());
+            throw new IllegalArgumentException("Slot " + id + " is already occupied by " + Block.blocksList[id] + " when adding " + this);
         }
         this.material = material;
@@ -308,38 +308,38 @@
         Block.isBlockContainer[id] = false;
     }
-    
+
     protected Block(final int id, final int blockIndex, final Material material) {
         this(id, material);
         this.blockIndexInTexture = blockIndex;
     }
-    
+
     protected Block setStepSound(final StepSound stepSound) {
         this.stepSound = stepSound;
         return this;
     }
-    
+
     protected Block setLightOpacity(final int opacity) {
         Block.lightOpacity[this.blockID] = opacity;
         return this;
     }
-    
+
     protected Block setLightValue(final float value) {
-        Block.lightValue[this.blockID] = (int)(15.0f * value);
+        Block.lightValue[this.blockID] = (int) (15.0f * value);
         return this;
     }
-    
+
     protected Block setResistance(final float resistance) {
         this.resistance = resistance * 3.0f;
         return this;
     }
-    
+
     private boolean getCanBlockGrass() {
         return false;
     }
-    
+
     public int getRenderType() {
         return 0;
     }
-    
+
     protected Block setHardness(final float hardness) {
         this.hardness = hardness;
@@ -349,9 +349,9 @@
         return this;
     }
-    
+
     protected void setTickOnLoad(final boolean doesTickOnLoad) {
         Block.tickOnLoad[this.blockID] = doesTickOnLoad;
     }
-    
+
     public void setBlockBounds(final float minX, final float minY, final float minZ, final float maxX, final float maxY, final float maxZ) {
         this.minX = minX;
@@ -362,21 +362,21 @@
         this.maxZ = maxZ;
     }
-    
+
     public boolean shouldSideBeRendered(final IBlockAccess blockAccess, final int x, final int y, final int z, final int side) {
         return (side == 0 && this.minY > 0.0) || (side == 1 && this.maxY < 1.0) || (side == 2 && this.minZ > 0.0) || (side == 3 && this.maxZ < 1.0) || (side == 4 && this.minX > 0.0) || (side == 5 && this.maxX < 1.0) || !blockAccess.isBlockNormalCube(x, y, z);
     }
-    
+
     public int getBlockTextureFromSide(final int side) {
         return this.blockIndexInTexture;
     }
-    
+
     public int getBlockTexture(final IBlockAccess iBlockAccess, final int n, final int n2, final int n3, final int n4) {
         return this.getBlockTextureFromSideAndMetadata(n4, iBlockAccess.getBlockMetadata(n, n2, n3));
     }
-    
+
     public int getBlockTextureFromSideAndMetadata(final int n, final int n2) {
         return this.getBlockTextureFromSide(n);
     }
-    
+
     public void getCollidingBoundingBoxes(final World world, final int x, final int y, final int z, final AxisAlignedBB aabb, final ArrayList arrayList) {
         final AxisAlignedBB axisAlignedBB7 = this.getCollisionBoundingBoxFromPool(world, x, y, z);
@@ -385,48 +385,48 @@
         }
     }
-    
+
     public AxisAlignedBB getCollisionBoundingBoxFromPool(final World world, final int x, final int y, final int z) {
         return AxisAlignedBB.getBoundingBoxFromPool(x + this.minX, y + this.minY, z + this.minZ, x + this.maxX, y + this.maxY, z + this.maxZ);
     }
-    
+
     public boolean isOpaqueCube() {
         return true;
     }
-    
+
     public boolean canCollideCheck(final int i1, final boolean z2) {
         return this.isCollidable();
     }
-    
+
     public boolean isCollidable() {
         return true;
     }
-    
+
     public void updateTick(final World world, final int x, final int y, final int z, final Random random) {
     }
-    
+
     public void onBlockDestroyedByPlayer(final World world, final int x, final int y, final int z, final int flag) {
     }
-    
+
     public void onNeighborBlockChange(final World world, final int x, final int y, final int z, final int flag) {
     }
-    
+
     public int tickRate() {
         return 10;
     }
-    
+
     public void onBlockAdded(final World world, final int x, final int y, final int z) {
     }
-    
+
     public void onBlockRemoval(final World world, final int x, final int y, final int z) {
     }
-    
+
     public int quantityDropped(final Random random) {
         return 1;
     }
-    
+
     public int idDropped(final int count, final Random random) {
         return this.blockID;
     }
-    
+
     public float blockStrength(final EntityPlayer entityPlayer) {
         if (this.hardness < 0.0f) {
@@ -435,6 +435,5 @@
             }
             return 0.0f;
-        }
-        else {
+        } else {
             if (!entityPlayer.canHarvestBlock(this)) {
                 return 1.0f / this.hardness / 100.0f;
@@ -443,9 +442,9 @@
         }
     }
-    
+
     public void dropBlockAsItem(final World world, final int i2, final int i3, final int i4, final int i5) {
         this.dropBlockAsItemWithChance(world, i2, i3, i4, i5, 1.0f);
     }
-    
+
     public void dropBlockAsItemWithChance(final World world, final int x, final int y, final int z, final int i5, final float f6) {
         if (!world.multiplayerWorld) {
@@ -466,9 +465,9 @@
         }
     }
-    
+
     public float getExplosionResistance(final Entity entity) {
         return this.resistance / 5.0f;
     }
-    
+
     public MovingObjectPosition collisionRayTrace(final World world, final int x, final int y, final int z, Vec3D vector1, Vec3D vector2) {
         this.setBlockBoundsBasedOnState(world, x, y, z);
@@ -542,59 +541,59 @@
         return new MovingObjectPosition(x, y, z, b14, vec3D13.addVector(x, y, z));
     }
-    
+
     private boolean isVecInsideYZBounds(final Vec3D vector) {
         return vector != null && (vector.yCoord >= this.minY && vector.yCoord <= this.maxY && vector.zCoord >= this.minZ && vector.zCoord <= this.maxZ);
     }
-    
+
     private boolean isVecInsideXZBounds(final Vec3D vector) {
         return vector != null && (vector.xCoord >= this.minX && vector.xCoord <= this.maxX && vector.zCoord >= this.minZ && vector.zCoord <= this.maxZ);
     }
-    
+
     private boolean isVecInsideXYBounds(final Vec3D vector) {
         return vector != null && (vector.xCoord >= this.minX && vector.xCoord <= this.maxX && vector.yCoord >= this.minY && vector.yCoord <= this.maxY);
     }
-    
+
     public void onBlockDestroyedByExplosion(final World world, final int x, final int y, final int z) {
     }
-    
+
     public boolean canPlaceBlockAt(final World world, final int x, final int y, final int z) {
         final int i5 = world.getBlockId(x, y, z);
         return i5 == 0 || Block.blocksList[i5].material.getIsLiquid();
     }
-    
+
     public boolean blockActivated(final World world, final int x, final int y, final int z, final EntityPlayer entityPlayer) {
         return false;
     }
-    
+
     public void onEntityWalking(final World world, final int x, final int y, final int z, final Entity entity) {
     }
-    
+
     public void onBlockPlaced(final World world, final int x, final int y, final int z, final int notifyFlag) {
     }
-    
+
     public void onBlockClicked(final World world, final int x, final int y, final int z, final EntityPlayer entityPlayer) {
     }
-    
+
     public void velocityToAddToEntity(final World world, final int x, final int y, final int z, final Entity entity, final Vec3D vector) {
     }
-    
+
     public void setBlockBoundsBasedOnState(final IBlockAccess blockAccess, final int x, final int y, final int z) {
     }
-    
+
     public boolean isPoweringTo(final IBlockAccess blockAccess, final int x, final int y, final int z, final int unused) {
         return false;
     }
-    
+
     public boolean canProvidePower() {
         return false;
     }
-    
+
     public void onEntityCollidedWithBlock(final World world, final int x, final int y, final int z, final Entity entity) {
     }
-    
+
     public boolean isIndirectlyPoweringTo(final World world, final int x, final int y, final int z, final int flag) {
         return false;
     }
-    
+
     public boolean canBlockStay(final World world, final int x, final int y, final int z) {
         return true;
