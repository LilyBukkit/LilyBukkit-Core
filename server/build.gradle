import java.nio.file.*

plugins {
    id 'java'
    id 'idea'
    id 'com.github.johnrengelman.shadow' version '7.1.2'
    id 'com.brambolt.gradle.patching' version '2022.05.01-7057'
}

abstract class DeletePatches extends DefaultTask {

	@Input
	String rmPath = "none";

    static def rm(Path path) {
        File file = new File(path.toString())
        if (file.isDirectory()) {
            for (File sf : file.listFiles()) {
                rm(sf.toPath())
            }
        }
        file.delete()
    }
	
	@TaskAction
	def delete() {
		rm(Paths.get(rmPath))
	}
}

abstract class InjectClasses extends DefaultTask {
	
	@Input
	String source = "none";
	@Input
	String dest = "none";
	
    static def cp(Path source, Path dest) {
        File file = new File(source.toString())
        if (file.isDirectory()) {
        	dest.toFile().mkdirs()
            for (String sf : file.list()) {
            	cp(source.resolve(sf), dest.resolve(sf))
            }
        }
        else if (file.isFile()) {
        	Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING)
        }
    }
	
	@TaskAction
	def copy() {
		cp(Paths.get(source), Paths.get(dest))
	}
}

abstract class CreateInjectClasses extends DefaultTask {

	@Input
	String source = "none";
	@Input
	String orig = "none";
	@Input
	String dest = "none";
	
    static def cpIfMissing(Path source, Path check, Path dest) {
        File file = source.toFile()
        if (file.isDirectory()) {
            for (String sf : file.list()) {
            	cpIfMissing(source.resolve(sf), check.resolve(sf), dest.resolve(sf))
            }
        }
        else if (file.isFile() && !check.toFile().exists()) {
        	dest.parent.toFile().mkdirs();
        	Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING)
        }
    }
    
    static def rm(Path path) {
        File file = new File(path.toString())
        if (file.isDirectory()) {
            for (File sf : file.listFiles()) {
                rm(sf.toPath())
            }
        }
        file.delete()
    }
	
	@TaskAction
	def copy() {
		rm(Paths.get(dest))
		cpIfMissing(Paths.get(source), Paths.get(orig), Paths.get(dest))
	}
}

tasks.register("deletePatches", DeletePatches) {
	rmPath = "${projectDir}/patches"
}

tasks.register("injectClasses", InjectClasses) {
	source = "${projectDir}/inject"
	dest = "${projectDir}/src/main/java"
}

tasks.register("ejectClasses", CreateInjectClasses) {
	source = "${projectDir}/src/main/java"
	orig = "${projectDir}/src/orig/java"
	dest = "${projectDir}/inject"
}

processPatches {
    content = "${projectDir}/src/orig/java"
    patches = "${projectDir}/patches"
    destination = "${projectDir}/src/main/java"
}

createPatches {
    content = "${projectDir}/src/orig/java"
    modified = "${projectDir}/src/main/java"
    destination = "${projectDir}/patches"
    dependsOn tasks.named("deletePatches").get()
}

jar {
    manifest {
        attributes "Main-Class": "net.minecraft.server.MinecraftServer"
    }
}

repositories{
    mavenCentral()
    maven {
        url = uri("https://maven.pkg.github.com/Vladg24YT/LilyBukkit-API")
        credentials {
            username = project.findProperty("gpr.user") ?: System.getenv("USERNAME")
            password = project.findProperty("gpr.key") ?: System.getenv("TOKEN")
        }
    }
}

sourceSets {
    main {
        java {
            srcDirs = ['src/main/java']
        }
        resources {
            srcDirs = ['src/main/resources']
        }
    }
}

dependencies{
    implementation group: "ru.vladthemountain", name: "lilybukkit", version: "1.0.8"
    //CraftBukkit
    implementation group: "net.sf.jopt-simple", name: "jopt-simple", version: "3.2"
    implementation group: "jline", name: "jline", version: "0.9.94"
}

group 'net.buj'
version '1.1-SNAPSHOT'
